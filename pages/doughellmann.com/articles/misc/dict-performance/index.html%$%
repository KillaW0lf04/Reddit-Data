<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>The Performance Impact of Using dict() Instead of {} in CPython 2.7 &mdash; Doug Hellmann</title><link rel="shortcut icon" href="../../../_static/favicon.ico" />
    <link rel="icon" href="../../../_static/favicon.ico" /><!-- Load modernizr and JQuery -->
    <script src="../../../_static/vendor/modernizr-2.6.2.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="../../../_static/vendor/jquery-1.8.2.min.js"><\/script>')</script>
    <script src="../../../_static/plugins.js"></script>
    <script src="../../../_static/main.js"></script>
    <link rel="stylesheet" href="../../../_static/pure-min.css" type="text/css">
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/font-awesome/css/font-awesome.min.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/webfont.css" type="text/css">
    <link rel="stylesheet" href="../../../_static/doughellmann.css" type="text/css">

    <link rel="alternate" type="application/atom+xml"
          title="Doug Hellmann"
          href="http://feeds.doughellmann.com/DougHellmann" />
    <link rel="alternate" type="application/atom+xml"
          title="PyMOTW Updates"
          href="http://feeds.doughellmann.com/PyMOTW" />
    <link rel="alternate" type="application/atom+xml"
          title="Python"
          href="http://feeds.doughellmann.com/doughellmann/python" />
    <link rel="alternate" type="application/atom+xml"
          title="OpenStack"
          href="http://feeds.doughellmann.com/doughellmann/openstack" />
    

    <meta name="verify-v1" content="5saTcOa2HLac4V85yUg3SARfun1PqT5Upu7IR/6fpv4="/>

    <!-- Open Graph metadata (http://ogp.me/) -->
    <meta property="og:title" content="The Performance Impact of Using dict() Instead of {} in CPython 2.7" />
    <meta property="og:url" content="" />
    <meta property="og:image" content="../../../_static/favicon.ico" />
    <meta property="og:site_name" content="doughellmann.com" /><meta property="og:type" content="article" />
    <meta property="og:article:published_time" content="2012-11-12T00:00:00" />

    <meta property="og:article:modified_time" content="2014-03-02T00:00:00" />

    <meta property="og:article:author" content="Doug Hellmann" /><meta property="og:article:tag" content="python" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.4.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script><script type="text/javascript" src="../../../_static/doctools.js"></script><script type="text/javascript" src="../../../_static/disqus.js"></script>
    

  </head>
  <body>

    <div class="pure-menu pure-menu-open pure-menu-horizontal" id="site-menu">
      <a class="pure-menu-heading" href="../../../index.html">Doug Hellmann</a>
    </div>

    <div class="pure-g-r" id="content-container">

      <div class="pure-u-1-12"></div>

      <div class="pure-u-5-6">

          <div class="content" id="2012-11-12-the-performance-impact-of-using-dict-instead-of-in-cpython-2-7-2">
            <div class="section" id="the-performance-impact-of-using-dict-instead-of-in-cpython-2-7">
<span id="article-misc-dict-performance"></span><h1>The Performance Impact of Using dict() Instead of {} in CPython 2.7<a class="headerlink" href="#the-performance-impact-of-using-dict-instead-of-in-cpython-2-7" title="Permalink to this headline">K</a></h1>
<p class="deck">I&#8217;ve been reviewing lot of code lately for various open source and
internal projects written in Python. As part of those reviews, I
have noticed what I think is a trend toward using <span class="docutils literal"><span class="pre">dict()</span></span>
instead of <span class="docutils literal"><span class="pre">{}</span></span> to create dictionaries. I don&#8217;t know exactly why
this trend has emerged. Perhaps the authors perceive <span class="docutils literal"><span class="pre">dict()</span></span> as
more readable than <span class="docutils literal"><span class="pre">{}</span></span>.  Whatever the reason, my intuition told
me calling the function version of the constructor for a dictionary
would impose a performance penalty. I studied what happens in both
cases to understand how significant that penalty is, and the
results confirmed my intuition.</p>
<div id="more"> </div><div class="section" id="tl-dr">
<h2>tl;dr<a class="headerlink" href="#tl-dr" title="Permalink to this headline">K</a></h2>
<p>With CPython 2.7, using <span class="docutils literal"><span class="pre">dict()</span></span> to create dictionaries takes up to
6 times longer and involves more memory allocation operations than the
literal syntax.  Use <span class="docutils literal"><span class="pre">{}</span></span> to create dictionaries, especially if you
are pre-populating them, unless the literal syntax does not work for
your case.</p>
</div>
<div class="section" id="initial-hypothesis">
<h2>Initial Hypothesis<a class="headerlink" href="#initial-hypothesis" title="Permalink to this headline">K</a></h2>
<p>I wanted to study the performance difference between the literal
syntax for creating a dictionary instance (<span class="docutils literal"><span class="pre">{}</span></span>) and using the name
of the class to create one (<span class="docutils literal"><span class="pre">dict()</span></span>).  I knew that the Python
interpreter is based on opcodes and that there are codes dedicated to
creating a dictionary that would not be invoked when the <span class="docutils literal"><span class="pre">dict()</span></span>
form was used instead of the literal form. I suspected that the extra
overhead for looking up the name <span class="docutils literal"><span class="pre">&quot;dict&quot;</span></span> and then calling the
function would make the &#8220;function&#8221; form slower.</p>
</div>
<div class="section" id="measuring-performance">
<h2>Measuring Performance<a class="headerlink" href="#measuring-performance" title="Permalink to this headline">K</a></h2>
<p>I began my analysis by applying <a class="reference external" href="http://pymotw.com/2/timeit">timeit</a> to see if the
performance difference was even measurable.</p>
<div class="highlight-python"><div class="highlight"><pre>$ python2.7 -m timeit -n 1000000 -r 5 -v &#39;dict()&#39;
raw times: 0.24 0.24 0.24 0.239 0.24
1000000 loops, best of 5: 0.239 usec per loop

$ python2.7 -m timeit -n 1000000 -r 5 -v &#39;{}&#39;
raw times: 0.0417 0.0413 0.0407 0.0411 0.042
1000000 loops, best of 5: 0.0407 usec per loop
</pre></div>
</div>
<p>Immediately I could see that not only was there a difference, it was
even more significant than I expected. Using <span class="docutils literal"><span class="pre">dict()</span></span> to create an
empty dictionary took 6 times longer than using the literal
syntax. Would the difference be the same if the dictionary had
members?</p>
<div class="callout line-block">
<div class="line">Using dict() to create an empty dictionary took</div>
<div class="line">6 times longer than using the literal syntax.</div>
</div>
<div class="highlight-python"><div class="highlight"><pre>$ python2.7 -m timeit -n 1000000 -r 5 -v &#39;dict(a=&quot;A&quot;, b=&quot;B&quot;, c=&quot;C&quot;)&#39;
raw times: 0.56 0.548 0.563 0.563 0.556
1000000 loops, best of 5: 0.548 usec per loop

$ python2.7 -m timeit -n 1000000 -r 5 -v &#39;{&quot;a&quot;: &quot;A&quot;, &quot;b&quot;: &quot;B&quot;, &quot;c&quot;: &quot;C&quot;}&#39;
raw times: 0.178 0.178 0.18 0.177 0.179
1000000 loops, best of 5: 0.177 usec per loop
</pre></div>
</div>
<p>Passing a few members to the dictionary brought the difference closer
together, but the function form was still taking three times as long.</p>
</div>
<div class="section" id="what-is-going-on">
<h2>What is going on?<a class="headerlink" href="#what-is-going-on" title="Permalink to this headline">K</a></h2>
<p>After establishing the performance difference, I asked myself what was
going on to cause such a significant slowdown. To answer that
question, I needed to look more deeply into what the interpreter was
doing as it processed each expression. I wanted to see which (and how
many) opcodes were being executed. I used <a class="reference external" href="http://pymotw.com/2/dis">dis</a> to
<em>disassemble</em> the Python expressions to see which opcodes implement
each.</p>
<p>To use dis from the command line, I needed input files containing the
different expressions I was studying. I created <span class="docutils literal"><span class="pre">func.py</span></span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nb">dict</span><span class="p">()</span>
</pre></div>
</div>
<p>and <span class="docutils literal"><span class="pre">literal.py</span></span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">{}</span>
</pre></div>
</div>
<p>The output of dis is arranged in columns with the original source line
number, the instruction âaddressâ within the code object, the opcode
name, and any arguments passed to the opcode.</p>
<div class="highlight-python"><div class="highlight"><pre>$ python2.7 -m dis func.py
  1           0 LOAD_NAME                0 (dict)
              3 CALL_FUNCTION            0
              6 POP_TOP
              7 LOAD_CONST               0 (None)
             10 RETURN_VALUE
</pre></div>
</div>
<p>The function form uses two separate opcodes: <span class="docutils literal"><span class="pre">LOAD_NAME</span></span> to find the
object associated with the name &#8220;dict&#8221;, and <span class="docutils literal"><span class="pre">CALL_FUNCTION</span></span> to
invoke it. The last three opcodes are not involved in creating or
populating the dictionary, and appear in both versions of the code, so
I ignored them for my analysis.</p>
<p>The literal form uses a special opcode to create the dictionary:</p>
<div class="highlight-python"><div class="highlight"><pre>$ python2.7 -m dis literal.py
  1           0 BUILD_MAP                0
              3 POP_TOP
              4 LOAD_CONST               0 (None)
              7 RETURN_VALUE
</pre></div>
</div>
<p>The <span class="docutils literal"><span class="pre">BUILD_MAP</span></span> opcode creates a new empty dictionary instance and
places it on the top of the interpreter&#8217;s stack.</p>
<p>After comparing the two sets of opcodes, I suspected that the
<span class="docutils literal"><span class="pre">CALL_FUNCTION</span></span> operation was the culprit, since calling functions
is relatively expensive in Python. However, these were trivial
examples and did not look like what I was seeing in code reviews. Most
of the actual code I had seen was populating the dictionary as it
created it, and I wanted to understand what difference that would
make.</p>
</div>
<div class="section" id="examining-more-complex-examples">
<h2>Examining More Complex Examples<a class="headerlink" href="#examining-more-complex-examples" title="Permalink to this headline">K</a></h2>
<p>I created two new source files that set three key/value pairs in the
dictionary as it is created. I started with <span class="docutils literal"><span class="pre">func-members.py</span></span>, which
instantiated a dictionary with the same members using the <span class="docutils literal"><span class="pre">dict()</span></span>
function.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="s">&quot;A&quot;</span><span class="p">,</span>
     <span class="n">b</span><span class="o">=</span><span class="s">&quot;B&quot;</span><span class="p">,</span>
     <span class="n">c</span><span class="o">=</span><span class="s">&quot;C&quot;</span><span class="p">,</span>
     <span class="p">)</span>
</pre></div>
</td></tr></table></div>
<div class="callout line-block">
<div class="line">I realized that in order to really understand what was going on,</div>
<div class="line">I would have to look at the interpreter implementation.</div>
</div>
<p>The disassembled version of <span class="docutils literal"><span class="pre">func-members.py</span></span> started the same way
as the earlier example, looking for the <span class="xref py py-func docutils literal"><span class="pre">dict()</span></span> function:</p>
<div class="highlight-python"><div class="highlight"><pre>$ python2.7 -m dis func-members.py
  1           0 LOAD_NAME                0 (dict)
</pre></div>
</div>
<p>Then it showed key/value pairs being pushed onto the stack using
<span class="docutils literal"><span class="pre">LOAD_CONST</span></span> to create named arguments for the function.</p>
<div class="highlight-python"><div class="highlight"><pre>            3 LOAD_CONST               0 (&#39;a&#39;)
            6 LOAD_CONST               1 (&#39;A&#39;)
            9 LOAD_CONST               2 (&#39;b&#39;)

2          12 LOAD_CONST               3 (&#39;B&#39;)
           15 LOAD_CONST               4 (&#39;c&#39;)

3          18 LOAD_CONST               5 (&#39;C&#39;)
</pre></div>
</div>
<p>Finally <span class="xref py py-func docutils literal"><span class="pre">dict()</span></span> was called:</p>
<div class="highlight-python"><div class="highlight"><pre>21 CALL_FUNCTION          768
24 POP_TOP
25 LOAD_CONST               6 (None)
28 RETURN_VALUE
</pre></div>
</div>
<p>Next I created <span class="docutils literal"><span class="pre">literal-members.py</span></span>:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">{</span><span class="s">&quot;a&quot;</span><span class="p">:</span> <span class="s">&quot;A&quot;</span><span class="p">,</span>
 <span class="s">&quot;b&quot;</span><span class="p">:</span> <span class="s">&quot;B&quot;</span><span class="p">,</span>
 <span class="s">&quot;c&quot;</span><span class="p">:</span> <span class="s">&quot;C&quot;</span><span class="p">,</span>
 <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The disassembled version of this example showed a few differences from
the literal example without any values. First, the argument to
<span class="docutils literal"><span class="pre">BUILD_MAP</span></span> was 3 instead of 0, indicating that there were three
key/value pairs on the stack to go into the dictionary.</p>
<div class="highlight-python"><div class="highlight"><pre>$ python2.7 -m dis literal-members.py
  1           0 BUILD_MAP                3
</pre></div>
</div>
<p>It also showed the values and then keys being pushed onto the stack
using <span class="docutils literal"><span class="pre">LOAD_CONST</span></span>.</p>
<div class="highlight-python"><div class="highlight"><pre>3 LOAD_CONST               0 (&#39;A&#39;)
6 LOAD_CONST               1 (&#39;a&#39;)
</pre></div>
</div>
<p>Finally, a new opcode, <span class="docutils literal"><span class="pre">STORE_MAP</span></span>, appeared once after each
key/value pair is processed.</p>
<div class="highlight-python"><div class="highlight"><pre>9 STORE_MAP
</pre></div>
</div>
<p>The same pattern repeated for each of the other two key/value pairs.</p>
<div class="highlight-python"><div class="highlight"><pre>2          10 LOAD_CONST               2 (&#39;B&#39;)
           13 LOAD_CONST               3 (&#39;b&#39;)
           16 STORE_MAP

3          17 LOAD_CONST               4 (&#39;C&#39;)
           20 LOAD_CONST               5 (&#39;c&#39;)
           23 STORE_MAP
           24 POP_TOP
           25 LOAD_CONST               6 (None)
           28 RETURN_VALUE
</pre></div>
</div>
<p>After looking at the output more closely, I noticed that there were
actually <em>fewer</em> opcodes in the function form than the literal
form. There were no <span class="docutils literal"><span class="pre">STORE_MAP</span></span> opcodes, just the <span class="docutils literal"><span class="pre">CALL_FUNCTION</span></span>
after all of the items were on the stack. At this point I realized
that in order to really understand what was going on, I would have to
look at the interpreter implementation.</p>
</div>
<div class="section" id="interpreter-source">
<h2>Interpreter Source<a class="headerlink" href="#interpreter-source" title="Permalink to this headline">K</a></h2>
<p>Up to now, I had been examining the behavior of the interpreter by
feeding it inputs and seeing what it did with them. To examine it at a
deeper level, I had to download the source following the instructions
in the <a class="reference external" href="http://docs.python.org/devguide/">Dev Guide</a>.</p>
<div class="highlight-python"><div class="highlight"><pre>$ hg clone http://hg.python.org/cpython
destination directory: cpython
requesting all changes
adding changesets
adding manifests
adding file changes
added 80406 changesets with 178013 changes to 9805 files (+2 heads)
updating to branch default
3750 files updated, 0 files merged, 0 files removed, 0 files unresolved

$ cd cpython
</pre></div>
</div>
<p>And, since I am looking at Python 2.7 rather than 3.3:</p>
<div class="highlight-python"><div class="highlight"><pre>$ hg update 2.7
3768 files updated, 0 files merged, 810 files removed, 0 files unresolved
</pre></div>
</div>
<p>The interpreter evaluates opcodes in a loop defined in
<span class="xref py py-func docutils literal"><span class="pre">PyEval_EvalFrameEx()</span></span> in <a class="reference external" href="http://hg.python.org/cpython/file/121872879e91/Python/ceval.c">Python/ceval.c</a>. Each opcode name
corresponds to an entry in the <span class="docutils literal"><span class="pre">switch</span></span> statement. For example, the
<span class="docutils literal"><span class="pre">POP_TOP</span></span> opcode that appears near the end of each disassembled
example is implemented as:</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre>        <span class="k">case</span> <span class="n">POP_TOP</span>:
            <span class="n">v</span> <span class="o">=</span> <span class="n">POP</span><span class="p">();</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">fast_next_opcode</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>The top-most item is removed from the stack and its reference count is
decremented to allow it (eventually) to be garbage collected. After
orienting myself in the source, I was ready to trace through the
opcodes used in the examples above.</p>
</div>
<div class="section" id="what-happens-when-you-call-dict">
<h2>What Happens When You Call dict()?<a class="headerlink" href="#what-happens-when-you-call-dict" title="Permalink to this headline">K</a></h2>
<p>The disassembly above shows that the opcodes used to call <span class="xref py py-func docutils literal"><span class="pre">dict()</span></span>
to create a dictionary are <span class="docutils literal"><span class="pre">LOAD_NAME</span></span>, <span class="docutils literal"><span class="pre">LOAD_CONST</span></span>, and
<span class="docutils literal"><span class="pre">CALL_FUNCTION</span></span>.</p>
<p>The <span class="docutils literal"><span class="pre">LOAD_NAME</span></span> opcode finds the object associated with the given
name (&#8220;dict&#8221; in this case) and puts it on top of the stack.</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre></div></td><td class="code"><div class="highlight"><pre>        <span class="k">case</span> <span class="n">LOAD_NAME</span>:
            <span class="n">w</span> <span class="o">=</span> <span class="n">GETITEM</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">oparg</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">v</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">f_locals</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">PyErr_Format</span><span class="p">(</span><span class="n">PyExc_SystemError</span><span class="p">,</span>
                             <span class="s">&quot;no locals when loading %s&quot;</span><span class="p">,</span>
                             <span class="n">PyObject_REPR</span><span class="p">(</span><span class="n">w</span><span class="p">));</span>
                <span class="n">why</span> <span class="o">=</span> <span class="n">WHY_EXCEPTION</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">PyDict_CheckExact</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">PyDict_GetItem</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
                <span class="n">Py_XINCREF</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">PyObject_GetItem</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">PyErr_Occurred</span><span class="p">())</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyErr_ExceptionMatches</span><span class="p">(</span>
                                    <span class="n">PyExc_KeyError</span><span class="p">))</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="n">PyErr_Clear</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">PyDict_GetItem</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_globals</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">PyDict_GetItem</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_builtins</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">format_exc_check_arg</span><span class="p">(</span>
                                    <span class="n">PyExc_NameError</span><span class="p">,</span>
                                    <span class="n">NAME_ERROR_MSG</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">PUSH</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="k">continue</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Three separate namespaces (represented as dictionaries) are
searched. First, the local namespace from inside any function scope,
followed by the module global namespace, and then the set of built-ins.</p>
<p><span class="docutils literal"><span class="pre">LOAD_CONST</span></span> is the next opcode used. It pushes literal constant
values onto the interpreter&#8217;s stack:</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre>        <span class="k">case</span> <span class="n">LOAD_CONST</span>:
            <span class="n">x</span> <span class="o">=</span> <span class="n">GETITEM</span><span class="p">(</span><span class="n">consts</span><span class="p">,</span> <span class="n">oparg</span><span class="p">);</span>
            <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="n">PUSH</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="k">goto</span> <span class="n">fast_next_opcode</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>The <span class="docutils literal"><span class="pre">oparg</span></span> value indicates which constant to take out of the set of
constants found in the code object. The constant&#8217;s reference count is
increased and then it is pushed onto the top of the stack. This is an
inexpensive operation since no name look-up is needed.</p>
<p>The portion of the implementation of <span class="docutils literal"><span class="pre">CALL_FUNCTION</span></span> in the case
statement looks similarly simple:</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre>        <span class="k">case</span> <span class="n">CALL_FUNCTION</span>:
        <span class="p">{</span>
            <span class="n">PyObject</span> <span class="o">**</span><span class="n">sp</span><span class="p">;</span>
            <span class="n">PCALL</span><span class="p">(</span><span class="n">PCALL_ALL</span><span class="p">);</span>
            <span class="n">sp</span> <span class="o">=</span> <span class="n">stack_pointer</span><span class="p">;</span>
<span class="cp">#ifdef WITH_TSC</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">call_function</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="p">,</span> <span class="n">oparg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intr0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intr1</span><span class="p">);</span>
<span class="cp">#else</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">call_function</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sp</span><span class="p">,</span> <span class="n">oparg</span><span class="p">);</span>
<span class="cp">#endif</span>
            <span class="n">stack_pointer</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>
            <span class="n">PUSH</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The function is called and its return value is pushed onto the
stack. (The <span class="docutils literal"><span class="pre">WITH_TSC</span></span> conditional compilation instruction controls
whether the Pentium timestamp counter is used, and can be ignored for
this general analysis.)</p>
<p>The implementation of <span class="xref py py-func docutils literal"><span class="pre">call_function()</span></span> starts to expose some of
the complexity of calling Python functions.</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">call_function</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">***</span><span class="n">pp_stack</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oparg</span>
<span class="cp">#ifdef WITH_TSC</span>
                <span class="p">,</span> <span class="n">uint64</span><span class="o">*</span> <span class="n">pintr0</span><span class="p">,</span> <span class="n">uint64</span><span class="o">*</span> <span class="n">pintr1</span>
<span class="cp">#endif</span>
                <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">na</span> <span class="o">=</span> <span class="n">oparg</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">nk</span> <span class="o">=</span> <span class="p">(</span><span class="n">oparg</span><span class="o">&gt;&gt;</span><span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">na</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nk</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">**</span><span class="n">pfunc</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">pp_stack</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">func</span> <span class="o">=</span> <span class="o">*</span><span class="n">pfunc</span><span class="p">;</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">w</span><span class="p">;</span>

    <span class="cm">/* Always dispatch PyCFunction first, because these are</span>
<span class="cm">       presumed to be the most frequent callable object.</span>
<span class="cm">    */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyCFunction_Check</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">nk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">PyCFunction_GET_FLAGS</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
        <span class="n">PyThreadState</span> <span class="o">*</span><span class="n">tstate</span> <span class="o">=</span> <span class="n">PyThreadState_GET</span><span class="p">();</span>

        <span class="n">PCALL</span><span class="p">(</span><span class="n">PCALL_CFUNCTION</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">METH_NOARGS</span> <span class="o">|</span> <span class="n">METH_O</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">PyCFunction</span> <span class="n">meth</span> <span class="o">=</span> <span class="n">PyCFunction_GET_FUNCTION</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
            <span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">PyCFunction_GET_SELF</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">METH_NOARGS</span> <span class="o">&amp;&amp;</span> <span class="n">na</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">C_TRACE</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">meth</span><span class="p">)(</span><span class="n">self</span><span class="p">,</span><span class="nb">NULL</span><span class="p">));</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">METH_O</span> <span class="o">&amp;&amp;</span> <span class="n">na</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">PyObject</span> <span class="o">*</span><span class="n">arg</span> <span class="o">=</span> <span class="n">EXT_POP</span><span class="p">(</span><span class="o">*</span><span class="n">pp_stack</span><span class="p">);</span>
                <span class="n">C_TRACE</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">meth</span><span class="p">)(</span><span class="n">self</span><span class="p">,</span><span class="n">arg</span><span class="p">));</span>
                <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">err_args</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">na</span><span class="p">);</span>
                <span class="n">x</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">PyObject</span> <span class="o">*</span><span class="n">callargs</span><span class="p">;</span>
            <span class="n">callargs</span> <span class="o">=</span> <span class="n">load_args</span><span class="p">(</span><span class="n">pp_stack</span><span class="p">,</span> <span class="n">na</span><span class="p">);</span>
            <span class="n">READ_TIMESTAMP</span><span class="p">(</span><span class="o">*</span><span class="n">pintr0</span><span class="p">);</span>
            <span class="n">C_TRACE</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">PyCFunction_Call</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">callargs</span><span class="p">,</span><span class="nb">NULL</span><span class="p">));</span>
            <span class="n">READ_TIMESTAMP</span><span class="p">(</span><span class="o">*</span><span class="n">pintr1</span><span class="p">);</span>
            <span class="n">Py_XDECREF</span><span class="p">(</span><span class="n">callargs</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">PyMethod_Check</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">PyMethod_GET_SELF</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/* optimize access to bound methods */</span>
            <span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">PyMethod_GET_SELF</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
            <span class="n">PCALL</span><span class="p">(</span><span class="n">PCALL_METHOD</span><span class="p">);</span>
            <span class="n">PCALL</span><span class="p">(</span><span class="n">PCALL_BOUND_METHOD</span><span class="p">);</span>
            <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">PyMethod_GET_FUNCTION</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
            <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="o">*</span><span class="n">pfunc</span><span class="p">);</span>
            <span class="o">*</span><span class="n">pfunc</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
            <span class="n">na</span><span class="o">++</span><span class="p">;</span>
            <span class="n">n</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span>
            <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
        <span class="n">READ_TIMESTAMP</span><span class="p">(</span><span class="o">*</span><span class="n">pintr0</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">PyFunction_Check</span><span class="p">(</span><span class="n">func</span><span class="p">))</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">fast_function</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">pp_stack</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">nk</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">do_call</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">pp_stack</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">nk</span><span class="p">);</span>
        <span class="n">READ_TIMESTAMP</span><span class="p">(</span><span class="o">*</span><span class="n">pintr1</span><span class="p">);</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Clear the stack of the function object.  Also removes</span>
<span class="cm">       the arguments in case they weren&#39;t consumed already</span>
<span class="cm">       (fast_function() and err_args() leave them on the stack).</span>
<span class="cm">     */</span>
    <span class="k">while</span> <span class="p">((</span><span class="o">*</span><span class="n">pp_stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">pfunc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">EXT_POP</span><span class="p">(</span><span class="o">*</span><span class="n">pp_stack</span><span class="p">);</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
        <span class="n">PCALL</span><span class="p">(</span><span class="n">PCALL_POP</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The number arguments the function is passed is given in <span class="docutils literal"><span class="pre">oparg</span></span>. The
low-end byte is the number of positional arguments, and the high-end
byte is the number of keyword arguments (lines 8-9). The value 768 in
the example above translates to 3 keyword arguments and 0 positional
arguments.</p>
<div class="highlight-python"><div class="highlight"><pre>21 CALL_FUNCTION          768
</pre></div>
</div>
<p>There are separate cases for built-in functions implemented in C,
function written in Python, and methods of objects. All of the cases
eventually use <span class="xref py py-func docutils literal"><span class="pre">load_args()</span></span> to pull the positional arguments off
of the stack as a tuple:</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">load_args</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">***</span><span class="n">pp_stack</span><span class="p">,</span> <span class="kt">int</span> <span class="n">na</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">PyTuple_New</span><span class="p">(</span><span class="n">na</span><span class="p">);</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">w</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">args</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">na</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">EXT_POP</span><span class="p">(</span><span class="o">*</span><span class="n">pp_stack</span><span class="p">);</span>
        <span class="n">PyTuple_SET_ITEM</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">args</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>And then <span class="xref py py-func docutils literal"><span class="pre">update_keyword_args()</span></span> is used to pull keyword arguments
off of the stack <em>as a dictionary</em>:</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">update_keyword_args</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">orig_kwdict</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nk</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">***</span><span class="n">pp_stack</span><span class="p">,</span>
                    <span class="n">PyObject</span> <span class="o">*</span><span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwdict</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">orig_kwdict</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">kwdict</span> <span class="o">=</span> <span class="n">PyDict_New</span><span class="p">();</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">kwdict</span> <span class="o">=</span> <span class="n">PyDict_Copy</span><span class="p">(</span><span class="n">orig_kwdict</span><span class="p">);</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">orig_kwdict</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">kwdict</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">nk</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
        <span class="n">PyObject</span> <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="n">EXT_POP</span><span class="p">(</span><span class="o">*</span><span class="n">pp_stack</span><span class="p">);</span>
        <span class="n">PyObject</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="n">EXT_POP</span><span class="p">(</span><span class="o">*</span><span class="n">pp_stack</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">PyDict_GetItem</span><span class="p">(</span><span class="n">kwdict</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">PyErr_Format</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
                         <span class="s">&quot;%.200s%s got multiple values &quot;</span>
                         <span class="s">&quot;for keyword argument &#39;%.200s&#39;&quot;</span><span class="p">,</span>
                         <span class="n">PyEval_GetFuncName</span><span class="p">(</span><span class="n">func</span><span class="p">),</span>
                         <span class="n">PyEval_GetFuncDesc</span><span class="p">(</span><span class="n">func</span><span class="p">),</span>
                         <span class="n">PyString_AsString</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">kwdict</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">PyDict_SetItem</span><span class="p">(</span><span class="n">kwdict</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">kwdict</span><span class="p">);</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">kwdict</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>That&#8217;s right.</p>
<div class="callout line-block">
<div class="line">To pass keyword arguments to dict() to instantiate a dictionary,</div>
<div class="line">first another dictionary is created.</div>
</div>
<p>After the arguments are prepared, they are passed to <span class="xref py py-func docutils literal"><span class="pre">dict()</span></span>.
The implementation of the dictionary object is found in
<a class="reference external" href="http://hg.python.org/cpython/file/121872879e91/Objects/dictobject.c">Objects/dictobject.c</a>, and the <span class="xref py py-class docutils literal"><span class="pre">dict</span></span> type is defined as:</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">PyTypeObject</span> <span class="n">PyDict_Type</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">PyVarObject_HEAD_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">PyType_Type</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="s">&quot;dict&quot;</span><span class="p">,</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">PyDictObject</span><span class="p">),</span>
    <span class="mi">0</span><span class="p">,</span>
    <span class="p">(</span><span class="n">destructor</span><span class="p">)</span><span class="n">dict_dealloc</span><span class="p">,</span>                   <span class="cm">/* tp_dealloc */</span>
    <span class="p">(</span><span class="n">printfunc</span><span class="p">)</span><span class="n">dict_print</span><span class="p">,</span>                      <span class="cm">/* tp_print */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_getattr */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_setattr */</span>
    <span class="p">(</span><span class="n">cmpfunc</span><span class="p">)</span><span class="n">dict_compare</span><span class="p">,</span>                      <span class="cm">/* tp_compare */</span>
    <span class="p">(</span><span class="n">reprfunc</span><span class="p">)</span><span class="n">dict_repr</span><span class="p">,</span>                        <span class="cm">/* tp_repr */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_as_number */</span>
    <span class="o">&amp;</span><span class="n">dict_as_sequence</span><span class="p">,</span>                          <span class="cm">/* tp_as_sequence */</span>
    <span class="o">&amp;</span><span class="n">dict_as_mapping</span><span class="p">,</span>                           <span class="cm">/* tp_as_mapping */</span>
    <span class="p">(</span><span class="n">hashfunc</span><span class="p">)</span><span class="n">PyObject_HashNotImplemented</span><span class="p">,</span>      <span class="cm">/* tp_hash */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_call */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_str */</span>
    <span class="n">PyObject_GenericGetAttr</span><span class="p">,</span>                    <span class="cm">/* tp_getattro */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_setattro */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_as_buffer */</span>
    <span class="n">Py_TPFLAGS_DEFAULT</span> <span class="o">|</span> <span class="n">Py_TPFLAGS_HAVE_GC</span> <span class="o">|</span>
        <span class="n">Py_TPFLAGS_BASETYPE</span> <span class="o">|</span> <span class="n">Py_TPFLAGS_DICT_SUBCLASS</span><span class="p">,</span>         <span class="cm">/* tp_flags */</span>
    <span class="n">dictionary_doc</span><span class="p">,</span>                             <span class="cm">/* tp_doc */</span>
    <span class="n">dict_traverse</span><span class="p">,</span>                              <span class="cm">/* tp_traverse */</span>
    <span class="n">dict_tp_clear</span><span class="p">,</span>                              <span class="cm">/* tp_clear */</span>
    <span class="n">dict_richcompare</span><span class="p">,</span>                           <span class="cm">/* tp_richcompare */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_weaklistoffset */</span>
    <span class="p">(</span><span class="n">getiterfunc</span><span class="p">)</span><span class="n">dict_iter</span><span class="p">,</span>                     <span class="cm">/* tp_iter */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_iternext */</span>
    <span class="n">mapp_methods</span><span class="p">,</span>                               <span class="cm">/* tp_methods */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_members */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_getset */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_base */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_dict */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_descr_get */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_descr_set */</span>
    <span class="mi">0</span><span class="p">,</span>                                          <span class="cm">/* tp_dictoffset */</span>
    <span class="n">dict_init</span><span class="p">,</span>                                  <span class="cm">/* tp_init */</span>
    <span class="n">PyType_GenericAlloc</span><span class="p">,</span>                        <span class="cm">/* tp_alloc */</span>
    <span class="n">dict_new</span><span class="p">,</span>                                   <span class="cm">/* tp_new */</span>
    <span class="n">PyObject_GC_Del</span><span class="p">,</span>                            <span class="cm">/* tp_free */</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p>Because <span class="xref py py-class docutils literal"><span class="pre">dict</span></span> is a class, <span class="xref py py-func docutils literal"><span class="pre">dict()</span></span> creates a new object and
then invokes the <span class="xref py py-func docutils literal"><span class="pre">__init__()</span></span> method. The initialization for
<span class="xref py py-class docutils literal"><span class="pre">dict</span></span> is handled by <span class="xref py py-func docutils literal"><span class="pre">dict_init()</span></span>:</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span>
<span class="nf">dict_init</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">dict_update_common</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="s">&quot;dict&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Which calls <span class="xref py py-func docutils literal"><span class="pre">dict_update_common()</span></span> to update the contents of the
dictionary with the arguments passed to the initialization function.</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span>
<span class="nf">dict_update_common</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">methname</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">arg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyArg_UnpackTuple</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">methname</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg</span><span class="p">))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">PyObject_HasAttrString</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s">&quot;keys&quot;</span><span class="p">))</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">PyDict_Merge</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">PyDict_MergeFromSeq2</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">kwds</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">PyDict_Merge</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>In this case, a set of keyword arguments are passed so the very last
case is triggered and <span class="xref py py-func docutils literal"><span class="pre">PyDict_Merge()</span></span> is used to copy the keyword
arguments into the dictionary. There are a couple of cases for
merging, but from what I can tell because there are two dictionaries
involved the first case applies. The target dictionary is resized to
be big enough to hold the new values, and then the items from the
merging dictionary are copied in one at a time.</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span>
<span class="nf">PyDict_Merge</span><span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">override</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">register</span> <span class="n">PyDictObject</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="o">*</span><span class="n">other</span><span class="p">;</span>
    <span class="k">register</span> <span class="n">Py_ssize_t</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">PyDictEntry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

    <span class="cm">/* We accept for the argument either a concrete dictionary object,</span>
<span class="cm">     * or an abstract &quot;mapping&quot; object.  For the former, we can do</span>
<span class="cm">     * things quite efficiently.  For the latter, we only require that</span>
<span class="cm">     * PyMapping_Keys() and PyObject_GetItem() be supported.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="o">!</span><span class="n">PyDict_Check</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">||</span> <span class="n">b</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">PyErr_BadInternalCall</span><span class="p">();</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">mp</span> <span class="o">=</span> <span class="p">(</span><span class="n">PyDictObject</span><span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyDict_Check</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">other</span> <span class="o">=</span> <span class="p">(</span><span class="n">PyDictObject</span><span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">other</span> <span class="o">==</span> <span class="n">mp</span> <span class="o">||</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">ma_used</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="cm">/* a.update(a) or a.update({}); nothing to do */</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">ma_used</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="cm">/* Since the target dict is empty, PyDict_GetItem()</span>
<span class="cm">             * always returns NULL.  Setting override to 1</span>
<span class="cm">             * skips the unnecessary test.</span>
<span class="cm">             */</span>
            <span class="n">override</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="cm">/* Do one big resize at the start, rather than</span>
<span class="cm">         * incrementally resizing as we insert new items.  Expect</span>
<span class="cm">         * that there will be no (or few) overlapping keys.</span>
<span class="cm">         */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">ma_fill</span> <span class="o">+</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">ma_used</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">ma_mask</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
           <span class="k">if</span> <span class="p">(</span><span class="n">dictresize</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">ma_used</span> <span class="o">+</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">ma_used</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
               <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">ma_mask</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">other</span><span class="o">-&gt;</span><span class="n">ma_table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">me_value</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
                <span class="p">(</span><span class="n">override</span> <span class="o">||</span>
                 <span class="n">PyDict_GetItem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">me_key</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">me_key</span><span class="p">);</span>
                <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">me_value</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">insertdict</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">me_key</span><span class="p">,</span>
                               <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">me_hash</span><span class="p">,</span>
                               <span class="n">entry</span><span class="o">-&gt;</span><span class="n">me_value</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* Do it the generic, slower way */</span>
        <span class="n">PyObject</span> <span class="o">*</span><span class="n">keys</span> <span class="o">=</span> <span class="n">PyMapping_Keys</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
        <span class="n">PyObject</span> <span class="o">*</span><span class="n">iter</span><span class="p">;</span>
        <span class="n">PyObject</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">keys</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="cm">/* Docstring says this is equivalent to E.keys() so</span>
<span class="cm">             * if E doesn&#39;t have a .keys() method we want</span>
<span class="cm">             * AttributeError to percolate up.  Might as well</span>
<span class="cm">             * do the same for any other error.</span>
<span class="cm">             */</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="n">iter</span> <span class="o">=</span> <span class="n">PyObject_GetIter</span><span class="p">(</span><span class="n">keys</span><span class="p">);</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">keys</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="n">PyIter_Next</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span> <span class="n">key</span><span class="p">;</span> <span class="n">key</span> <span class="o">=</span> <span class="n">PyIter_Next</span><span class="p">(</span><span class="n">iter</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">override</span> <span class="o">&amp;&amp;</span> <span class="n">PyDict_GetItem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">PyObject_GetItem</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
                <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">PyDict_SetItem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">PyErr_Occurred</span><span class="p">())</span>
            <span class="cm">/* Iterator completed, via error */</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="creating-a-dictionary-with">
<h2>Creating a Dictionary with {}<a class="headerlink" href="#creating-a-dictionary-with" title="Permalink to this headline">K</a></h2>
<p>The opcodes used to implement the literal examples are <span class="docutils literal"><span class="pre">BUILD_MAP</span></span>,
<span class="docutils literal"><span class="pre">LOAD_CONST</span></span>, and <span class="docutils literal"><span class="pre">STORE_MAP</span></span>. I started with the first opcode,
<span class="docutils literal"><span class="pre">BUILD_MAP</span></span>, which creates the dictionary instance:</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre>        <span class="k">case</span> <span class="n">BUILD_MAP</span>:
            <span class="n">x</span> <span class="o">=</span> <span class="n">_PyDict_NewPresized</span><span class="p">((</span><span class="n">Py_ssize_t</span><span class="p">)</span><span class="n">oparg</span><span class="p">);</span>
            <span class="n">PUSH</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>The dictionary is created using <span class="xref py py-func docutils literal"><span class="pre">_PyDict_NewPresized()</span></span>, from
<a class="reference external" href="http://hg.python.org/cpython/file/121872879e91/Objects/dictobject.c">Objects/dictobject.c</a>.</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Create a new dictionary pre-sized to hold an estimated number of elements.</span>
<span class="cm">   Underestimates are okay because the dictionary will resize as necessary.</span>
<span class="cm">   Overestimates just mean the dictionary will be more sparse than usual.</span>
<span class="cm">*/</span>

<span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">_PyDict_NewPresized</span><span class="p">(</span><span class="n">Py_ssize_t</span> <span class="n">minused</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span> <span class="o">=</span> <span class="n">PyDict_New</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">minused</span><span class="o">&gt;</span><span class="mi">5</span> <span class="o">&amp;&amp;</span> <span class="n">op</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">dictresize</span><span class="p">((</span><span class="n">PyDictObject</span> <span class="o">*</span><span class="p">)</span><span class="n">op</span><span class="p">,</span> <span class="n">minused</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">op</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The argument for <span class="docutils literal"><span class="pre">BUILD_MAP</span></span> is the number of items that are going
to be added to the new dictionary as it is created. The disassembly
for <span class="docutils literal"><span class="pre">literal-members.py</span></span> showed that value as <span class="docutils literal"><span class="pre">3</span></span> earlier.</p>
<div class="highlight-python"><div class="highlight"><pre>$ python2.7 -m dis literal-members.py
  1           0 BUILD_MAP                3
</pre></div>
</div>
<p>Specifying the initial number of items in the dictionary is an
optimization for managing memory, since it means the table size can be
set ahead of time and it does not need to be reallocated in some
cases.</p>
<p class="callout">The argument for BUILD_MAP is the number of items that are
going to be added to the new dictionary as it is created.</p>
<p>Each key/value pair is added to the dictionary using three
opcodes. Two instances of <span class="docutils literal"><span class="pre">LOAD_CONST</span></span> push the value, then the key,
onto the stack. Then a <span class="docutils literal"><span class="pre">STORE_MAP</span></span> opcode adds the pair to the
dictionary.</p>
<div class="highlight-python"><div class="highlight"><pre>2          10 LOAD_CONST               2 (&#39;B&#39;)
           13 LOAD_CONST               3 (&#39;b&#39;)
           16 STORE_MAP
</pre></div>
</div>
<p>As we saw early, <span class="docutils literal"><span class="pre">LOAD_CONST</span></span> is fairly straightforward and
economical. <span class="docutils literal"><span class="pre">STORE_MAP</span></span> looks for the key, value, and dictionary on
the stack and calls <span class="xref py py-func docutils literal"><span class="pre">PyDict_SetItem()</span></span> to add the new key/value
pair. The <span class="docutils literal"><span class="pre">STACKADJ(-2)</span></span> line removes the key and value off from the
stack.</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre>        <span class="k">case</span> <span class="n">STORE_MAP</span>:
            <span class="n">w</span> <span class="o">=</span> <span class="n">TOP</span><span class="p">();</span>     <span class="cm">/* key */</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">SECOND</span><span class="p">();</span>  <span class="cm">/* value */</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">THIRD</span><span class="p">();</span>   <span class="cm">/* dict */</span>
            <span class="n">STACKADJ</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
            <span class="n">assert</span> <span class="p">(</span><span class="n">PyDict_CheckExact</span><span class="p">(</span><span class="n">v</span><span class="p">));</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">PyDict_SetItem</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>  <span class="cm">/* v[w] = u */</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
            <span class="n">Py_DECREF</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p><span class="xref py py-func docutils literal"><span class="pre">PyDict_SetItem()</span></span> is the same function invoked when a program
uses <span class="docutils literal"><span class="pre">d[k]</span> <span class="pre">=</span> <span class="pre">v</span></span> to associate the value <span class="docutils literal"><span class="pre">v</span></span> with a key <span class="docutils literal"><span class="pre">k</span></span> in a
dictionary.</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span>
<span class="nf">PyDict_SetItem</span><span class="p">(</span><span class="k">register</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">register</span> <span class="kt">long</span> <span class="n">hash</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PyDict_Check</span><span class="p">(</span><span class="n">op</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">PyErr_BadInternalCall</span><span class="p">();</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PyString_CheckExact</span><span class="p">(</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">hash</span> <span class="o">=</span> <span class="p">((</span><span class="n">PyStringObject</span> <span class="o">*</span><span class="p">)</span><span class="n">key</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ob_shash</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">hash</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">hash</span> <span class="o">=</span> <span class="n">PyObject_Hash</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">hash</span> <span class="o">=</span> <span class="n">PyObject_Hash</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">hash</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">dict_set_item_by_hash_or_entry</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">hash</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The functions it calls handle resizing the internal data structure
used by the dictionary, if that&#8217;s necessary.</p>
</div>
<div class="section" id="extreme-tests">
<h2>Extreme Tests<a class="headerlink" href="#extreme-tests" title="Permalink to this headline">K</a></h2>
<p>I now had an answer explaining why the literal syntax was so much more
efficient than using the name to instantiate a dictionary. I had
noticed earlier, though, that the performance benefits were reduced
when I added a few key/value pairs so I wanted to see if that trend
continued as I added more arguments.</p>
<p>I decided to jump right to the maximum point, and create dictionaries
with 255 members. Because the number of keyword arguments passed to a
function is represented in a byte, a function may be passed at most
255 literal keyword arguments (you can pass more arguments if you
populate a dictionary and use the syntax <span class="docutils literal"><span class="pre">callable(**kwds)</span></span>, but 255
seemed like a reasonable number to test).</p>
<p>Not wanting to type out all of those arguments, I created one script to
generate a call to <span class="xref py py-func docutils literal"><span class="pre">dict()</span></span> with 255 arguments:</p>
<div class="highlight-python"><div class="highlight"><pre>#!/usr/bin/env python

print &#39;dict(&#39;,
for i in range(255):
    print &#39;a%d=%d,&#39; % (i, i),
print &#39;)&#39;
</pre></div>
</div>
<p>and another to create a literal dictionary with the same members:</p>
<div class="highlight-python"><div class="highlight"><pre>#!/usr/bin/env python

print &#39;{&#39;,
for i in range(255):
    print &#39;&quot;a%r&quot;: %r,&#39; % (i, i),
print &#39;}&#39;
</pre></div>
</div>
<p>I then ran the scripts, and passed their output to <span class="docutils literal"><span class="pre">timeit</span></span>. I
used fewer iterations, since it took longer to run each one and
process all of the arguments.</p>
<div class="highlight-python"><div class="highlight"><pre>$ python2.7 makebigfunc.py &gt; func-big.py
$ python2.7 -m timeit -n 10000 -r 5 -v &quot;$(cat func-big.py)&quot;
raw times: 0.214 0.211 0.211 0.216 0.221
10000 loops, best of 5: 21.1 usec per loop

$ python2.7 makebigdict.py &gt; literal-big.py
$ python2.7 -m timeit -n 10000 -r 5 -v &quot;$(cat literal-big.py)&quot;
raw times: 0.138 0.136 0.137 0.137 0.14
10000 loops, best of 5: 13.6 usec per loop
</pre></div>
</div>
<p>The difference has narrowed, but using <span class="xref py py-func docutils literal"><span class="pre">dict()</span></span> still takes 1.6
times as long as <span class="docutils literal"><span class="pre">{}</span></span>.</p>
</div>
<div class="section" id="conclusions">
<h2>Conclusions<a class="headerlink" href="#conclusions" title="Permalink to this headline">K</a></h2>
<p>In summary, calling <span class="xref py py-func docutils literal"><span class="pre">dict()</span></span> requires these steps:</p>
<ol class="arabic simple">
<li>Find the object associated with the name <span class="docutils literal"><span class="pre">&quot;dict&quot;</span></span> and push it
onto the stack.</li>
<li>Push the key/value pairs onto the stack as constant values.</li>
<li>Get the key/value pairs off of the stack and create a dictionary
to hold the keyword arguments to the function.</li>
<li>Call the constructor for <span class="xref py py-class docutils literal"><span class="pre">dict</span></span> to make a new object.</li>
<li>Initialize the new object by passing the keyword arguments to its
initialization method.</li>
<li>Resize the new <span class="xref py py-class docutils literal"><span class="pre">dict</span></span> and copy the key/value pairs into it
from the keyword arguments.</li>
</ol>
<p>Whereas using <span class="docutils literal"><span class="pre">{}</span></span> to create a dictionary uses only these steps:</p>
<ol class="arabic simple">
<li>Create an empty but pre-allocated dictionary instance.</li>
<li>Push the key/value pairs onto the stack as constant values.</li>
<li>Store each key/value pair in the dictionary.</li>
</ol>
<p>The times involved here are pretty small, but as a general principle I
try to avoid code constructions I know to introduce performance hits.
On the other hand, there may be times when using <span class="xref py py-func docutils literal"><span class="pre">dict()</span></span> is
necessary, or easier. For example, in versions of Python earlier than
2.7, creating a dictionary from an iterable required using a generator
expression as argument to <span class="xref py py-func docutils literal"><span class="pre">dict()</span></span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">some_iterable</span><span class="p">)</span>
</pre></div>
</div>
<p>With 2.7 and later, though, <em>dictionary comprehensions</em> are built into
the language syntax:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">some_iterable</span><span class="p">}</span>
</pre></div>
</div>
<p>So that eliminates one common case for calling <span class="xref py py-func docutils literal"><span class="pre">dict()</span></span>.  Using
the literal dictionary syntax feels more &#8220;pythonic&#8221; to me, so I try to
just do it anyway.</p>
</div>
</div>

    <div class="postmeta">
        <div class="tags">
          <span class="metatitle">Tags:</span>
          <a class="pill" href="../../../tags/python.html">python</a>
          </div>
        <div class="timestamp"><span class="metatitle">First posted: </span><span class="timestamp">November 12, 2012</span>
        </div>
        
        <div class="timestamp"><span class="metatitle">Last updated: </span><span class="timestamp">March 02, 2014</span>
        </div>
        </div>
    <div id="disqus_thread"></div><script type="text/javascript">    var disqus_shortname = "doughellmann";    var disqus_identifier = "2012/11/12/the-performance-impact-of-using-dict-instead-of-in-cpython-2-7-2";    disqus_thread();</script><noscript>Please enable JavaScript to view the    <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
          </div>

      </div><div class="pure-u-1-12"></div>

    </div><div id="footer"><div class="pure-g-r relbar">
        <div class="pure-u-1-3"><div class="relbar-next">
            <a href="../../10/29/stevedore-0-6.html"><i class="fa fa-arrow-circle-o-left fa-lg relicon-next"></i> stevedore 0.6</a>
          </div></div>
        <div class="pure-u-1-3"></div>
        <div class="pure-u-1-3"><div class="relbar-prev">
            <a href="../26/stevedore-0-7.html">stevedore 0.7 <i class="fa fa-arrow-circle-o-right fa-lg relicon-prev"></i></a>
          </div></div>
      </div><div class="pure-g-r">

        <div class="pure-u-1-3">
          <div class="footer-list">
            <h4>Recent Posts</h4>
            <ul><li><a href="../../../2014/06/23/stevedore-1-0-0-0a1.html"><i class="fa fa-caret-right fa-lg"></i> stevedore 1.0.0.0a1</a></li><li><a href="../../../2014/05/31/virtualenvwrapper-4-3.html"><i class="fa fa-caret-right fa-lg"></i> virtualenvwrapper 4.3</a></li><li><a href="../../../2014/05/31/sphinxcontrib-spelling-2-1-1.html"><i class="fa fa-caret-right fa-lg"></i> sphinxcontrib.spelling 2.1.1</a></li><li><a href="../../../2014/05/26/watering-time-practical-uses-for-python-s-calendar-module.html"><i class="fa fa-caret-right fa-lg"></i> Watering Time: Practical Uses for Python's Calendar Module</a></li><li><a href="../../../2014/05/02/wsme-0-6-1.html"><i class="fa fa-caret-right fa-lg"></i> WSME -- Web Services Made Easy -- 0.6.1</a></li></ul>
          </div>
        </div><div class="pure-u-1-3">
          <div class="footer-content">

            <div class="socialmedia">
              <a class="sociallink" href="../../../index.html"
       title="Home">
      <i class="fa fa-home fa-lg"></i></a>
              <a class="sociallink" href="../../../pages/about.html"
       title="About">
      <i class="fa fa-user fa-lg"></i></a>
              <a class="sociallink" href="http://www.twitter.com/doughellmann"
       title="Twitter">
      <i class="fa fa-twitter fa-lg"></i></a>
              <a class="sociallink" href="http://www.linkedin.com/in/doughellmann"
       title="LinkedIn">
      <i class="fa fa-linkedin fa-lg"></i></a><a class="sociallink" href="https://bitbucket.org/dhellmann"
       title="BitBucket">
      <i class="fa fa-bitbucket fa-lg"></i></a>
              <a class="sociallink" href="https://github.com/dhellmann"
       title="Github">
      <i class="fa fa-github-alt fa-lg"></i></a>
              <a class="sociallink" href="http://feeds.doughellmann.com/DougHellmann"
       title="Subscribe via RSS">
      <i class="fa fa-rss-square fa-lg"></i></a>
            </div>

            <div class="copyright">
              <a rel="author" href="../../../pages/about.html">&copy; Copyright 2006-2014, Doug Hellmann</a>
            </div>

            <div class="cc"><a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.en_US" rel="license"><img alt="Creative Commons License BY-NC-SA" style="border-width:0; align: center;" width="88" height="31" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFgAAAAfCAMAAABUFvrSAAAABGdBTUEAALGOfPtRkwAAAf5QTFRF////////////AAAADQwNDQ4NDg4OEBAQGRkZGxsbHxscICAgIx8gJCQkKCUmKCgoKCkoKSkpKSopKicnKioqLS0tMDAwMS0uMjExMjMxNTY1Pj8+Pzc5Pzs8QEBAQ0RDUFBQUFFQWldYXV5dYGBgY19haGVmbmxscHBwcHJvdXJzdnN0eHV2eXx5en15fH98fX98fnt8f4F+gICAgoWChIGChIWEhIaEh4aHiYyJjIqLjoeLj4+PkY+PkZORkZSRk5iTlZmUlpmWmJaXmpiZnp2dnqCdn5aan5+fn6Oeoqaho6Gho6ijpqqmq7GqrKurrLKrrbOsrrOtrrStr6+vr7Kvr7Sur7WusLOvsLWvsLavsbewsrexsrixs7iytLmztLqztbW1tbq0tru1t7y2uL23ub64ub65urm5ur+5ur+6u8C6u8C7vMC8vMG7vMG8vcK8vcK9vsK9vsO+v7+/v8O+v8S+wMS/wMW/wMXAwcXAwsfCw8fCw8jDxMfDxMjDxMnExcnExcnFxsrFxsrGx8vHyMfHyMzHyMzIycjIyc3Iyc3Jys3Jy8rLy87Ky8/Ky8/LzM/LzNDLzNDMzdDMzdHMzdHNztHNztLOz8/Pz9PP0NPP0NTQ0dTQ0dTR0tXR0tXS09bS1tXV39/f4N/g4+Pj6Ofn7+/v8fHx////rrSdFQAAAAN0Uk5TAAoO5yEBUwAAA+FJREFUSMe1lo9301QUx6uXUmaf0qJ26iTrRoVinUzjQNR1gAyH6Lqx6XTDoVvXbU7qhA5m7CgYWaTDlLa6AiFsba3t+y+9Sdr8OvVMi7zTnLTf5H7ee9/73n11PA1PpDkcADPRWPwKt8YLG2I2n89m7gh8iluJz0dnpqe+HBsdHRn+7w3JyF1cvpbk05mCJG8Xi9uPpMLdNJ9cXV5UyBNjoyMtkR2A3B9Tt8SCfLTTqUzC2XlMvpcRbnA/IPmryYnzoyM9XuWBt8eI21FBcAy5Qk4KtxkGtQ1I+fRNbnk+evHC5NhJDwATDDIAnhNa1ImdFQTHr6WEvNyFPFeATSTYgAu/dl3/I31jNR6bnZ76eDf4yxRb2Q+71aiz/0JB8JXkrZzCdbFVqrUhRHuu54XkytLczAUvBFADUB6ARwnyqEp/t02prK9XdAXBHC9KyPWVqd6qPhyzlOG55dhsL/hLDTD1A3rYAy+dRu6eXaGKruA75wi2hbqigNd+LYSRW6XUSh64l05dXYruA1OPZfAOD3vhObL/ILDvQkRXynSdvPpaiJB+TVHAfEZuA9d9amlVF7TJd3nu+xgwyu8AqNOnDGAM8/obOLhQpWQotPYReZ/SQdKuKQpY2DwKwFJbGwI4VhCSlxchSFUnNC+CCgaV9RAKoZKh1J4le9FmQv5SFQW88aATXGhEws8wrHb7AANc0CndQS+ag5ERaieke0FXvnkxoYL/1MGi7FSmmVBXMDOu3gLK5J2PMjdXv2tmBX6pDdKSkq39DWXh3G1KI4QYVmS3AHCIPnCXE+4hHy6PcfeQ6sV2lufiL2jJ0wasp4p2k/Z2CEXeeqahDBLS1/c8+dBIXq4IkFAiWQ1QtxtnUMz/wsXfBj+1LzdUKn17dvXXzEqfMoFDNWO57QCe22dskKB5g7zXbVN+i0RKumKxonrfzaIVys2wYu7TVrd0PXn1rOnJC4JTFjF5c19/gnXLFwj6jJJz1rOjoi63LnBRfbmNM+qNunG5baSufhu9OPX5my2VTWEzrHrRbIP8dHl+dnpyrIVDBME/q1u6/E9bGmt9i2AsQmeaFaFwIb22soSlfuL8SEtgOCJKB5BsKkNltWyK7zzWMY3X4exDc6GvsljoX5FzR+BxwdCbf3jAdjTJv5/S39H2B2iXpmgXpWB7iVrB0JuVzpgP07CUO2WKqX+oiVL/benKImhgOIzHf7hx/A/IBdHsQ6Nsmruilo4afVFqB8PLn2U2H8hbxeKWjH9YvuiwxNiMaNhALZptCg5d7zh+Sczmclnx0vEOax6ajdjucSMPTcD/97/Cp54Q929ZZbgcR3o0hAAAAABJRU5ErkJggg=="/></a>
            </div>

          </div></div><div class="pure-u-1-3">
          <div class="footer-list">
            <h4>Other Writing</h4>
            <ul>
              <li><a href="../../../archive.html"><i class="fa fa-archive fa-lg"></i> Site Archive</a></li>
              <li><a href="http://pymotw.com"><i class="fa fa-globe fa-lg"></i> PyMOTW.com</a></li>
              <li><a href="../../../pages/python-standard-library-by-example.html"><i class="fa fa-book fa-lg"></i> The Python Standard Library By Example</a></li>
            </ul>
          </div>
        </div></div></div><script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-1847381-1', 'doughellmann.com');
  ga('send', 'pageview');
</script>

  </body>
</html>