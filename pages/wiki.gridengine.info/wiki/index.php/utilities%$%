<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<title>Utilities - GridWiki</title>
<meta charset="UTF-8" />
<meta name="generator" content="MediaWiki 1.19.1" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="/wiki/opensearch_desc.php" title="GridWiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="http://wiki.gridengine.info/wiki/api.php?action=rsd" />
<link rel="alternate" type="application/atom+xml" title="GridWiki Atom feed" href="/wiki/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="http://wiki.gridengine.info/wiki/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cskins.vector&amp;only=styles&amp;skin=vector&amp;*" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}a.new,#quickbar a.new{color:#ba0000}

/* cache key: gridwikidb-grid_:resourceloader:filter:minify-css:7:c88e2bcd56513749bec09a7e29cb3ffa */
</style>

<script src="http://wiki.gridengine.info/wiki/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Utilities","wgTitle":"Utilities","wgCurRevisionId":5193,"wgArticleId":1834,"wgIsArticle":true,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgRelevantPageName":"Utilities","wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"highlightbroken":1,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,
"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false});;},{},{});mw.loader.implement("user.tokens",function($){mw.user.tokens.set({"editToken":"+\\","watchToken":false});;},{},{});

/* cache key: gridwikidb-grid_:resourceloader:filter:minify-js:7:9983699ab6150ffa89a90653b2338ac8 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax"]);
}</script>
<!--[if lt IE 7]><style type="text/css">body{behavior:url("/wiki/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Utilities skin-vector action-view">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<!-- content -->
		<div id="content" class="mw-body">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;"></div>
						<!-- firstHeading -->
			<h1 id="firstHeading" class="firstHeading">
				<span dir="auto">Utilities</span>
			</h1>
			<!-- /firstHeading -->
			<!-- bodyContent -->
			<div id="bodyContent">
								<!-- tagline -->
				<div id="siteSub">From GridWiki</div>
				<!-- /tagline -->
								<!-- subtitle -->
				<div id="contentSub"></div>
				<!-- /subtitle -->
																<!-- jumpto -->
				<div id="jump-to-nav" class="mw-jump">
					Jump to: <a href="#mw-head">navigation</a>,
					<a href="#p-search">search</a>
				</div>
				<!-- /jumpto -->
								<!-- bodycontent -->
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><table id="toc" class="toc"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Load_Script"><span class="tocnumber">1</span> <span class="toctext">Load Script</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Using_Ganglia_as_Load_Sensor"><span class="tocnumber">2</span> <span class="toctext">Using Ganglia as Load Sensor</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Modding_qstat"><span class="tocnumber">3</span> <span class="toctext">Modding qstat</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Modding_qstat_Redux"><span class="tocnumber">4</span> <span class="toctext">Modding qstat Redux</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#User_Management"><span class="tocnumber">5</span> <span class="toctext">User Management</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#qcd"><span class="tocnumber">6</span> <span class="toctext">qcd</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#qavailable_processors"><span class="tocnumber">7</span> <span class="toctext">qavailable_processors</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#qtail"><span class="tocnumber">8</span> <span class="toctext">qtail</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="#rj:_qsub_wrapper_script"><span class="tocnumber">9</span> <span class="toctext">rj: qsub wrapper script</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="#User_Job_Stats"><span class="tocnumber">10</span> <span class="toctext">User Job Stats</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="#qtime"><span class="tocnumber">11</span> <span class="toctext">qtime</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="#Queue_Job_Count"><span class="tocnumber">12</span> <span class="toctext">Queue Job Count</span></a></li>
<li class="toclevel-1 tocsection-13"><a href="#Change_Queue_State"><span class="tocnumber">13</span> <span class="toctext">Change Queue State</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="#filter-accounting"><span class="tocnumber">14</span> <span class="toctext">filter-accounting</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="#Other_Miscellaneous"><span class="tocnumber">15</span> <span class="toctext">Other Miscellaneous</span></a></li>
</ul>
</td></tr></table>
<h2> <span class="mw-headline" id="Load_Script"> Load Script </span></h2>
<p>The following script just creates jobs.  It is useful for testing your settings.  No error checking and you have to modify the <code>-q</code> option to fit with your system.
</p>
<pre>#!/bin/sh


# First argument is the number of jobs
# Second argument is the seconds to sleep

QSUB_OPTIONS="  \
                -q "'*&amp;!boinc'" \
                -cwd \
                -j y \
                -V \
                -N load \
                -o `pwd`/load.out \
"

for i in `seq $1`
do
  qsub $QSUB_OPTIONS /sjr/beodata/local/bin/vanilla_job.sh sleep $2
done
</pre>
<h2> <span class="mw-headline" id="Using_Ganglia_as_Load_Sensor"> Using Ganglia as Load Sensor </span></h2>
<p>See <a href="/wiki/index.php/Using_Ganglia_As_Load_Sensor" title="Using Ganglia As Load Sensor">Using Ganglia As Load Sensor</a> for guidance on using <a rel="nofollow" class="external text" href="http://ganglia.sourceforge.net">Ganglia</a> as a load sensor for Grid Engine.
</p>
<h2> <span class="mw-headline" id="Modding_qstat"> Modding qstat </span></h2>
<p>The output from <code>qstat -ext</code>, while complete, is overly verbose (and over 200 characters wide) in many cases.  In SGE 5.3, this will strip out bits about the Department, Deadline, PE Master, and Array Task columns; items frequently unused.  It makes a good alias (such as "eqstat", or something):
</p>
<pre> qstat -ext | cut -c 1-33,39-45,66-92,110-191
</pre>
<h2> <span class="mw-headline" id="Modding_qstat_Redux"> Modding qstat Redux </span></h2>
<p>A longer script, but more condensed output from Andy Schwierskott, pulled from the SGE mailing list:
</p>
<pre>  #!/bin/sh
     echo "JobId     P    S  Project     User Tot-Tkt   ovrts   otckt   dtckt   ftckt   stckt  shr"
  echo "---------------------------------------------------------------------------------------"
  qstat -ext -s rs | grep -v job-ID | sed /-------------/d | \
     gawk '{ printf("%5s&#160;%4s&#160;%4s&#160;%8s&#160;%8s&#160;%7s&#160;%7s&#160;%7s&#160;%7s&#160;%7s&#160;%7s&#160;%4s\n", \
                   $1, $2, $7, $5, $4, $13, $14, $15, $16, $17, $18, $19) }'
  echo "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
  qstat -ext -s p | grep -v job-ID | sed /-------------/d | \
      gawk '{ printf("%5s&#160;%4s&#160;%4s&#160;%8s&#160;%8s&#160;%7s&#160;%7s&#160;%7s&#160;%7s&#160;%7s&#160;%7s&#160;%4s\n", \
                  $1, $2, $7, $5, $4, $10, $11, $12, $13, $14, $15, $16 ); }'
</pre>
<h2> <span class="mw-headline" id="User_Management"> User Management </span></h2>
<p>If you have lots of users and groups to add at once, and your userlists map to unix groups, <code>qconf</code> can help automate this a bit.  This <code>awk</code> snippet looks for entries starting with "grp", and generates a <code>qconf</code> entry to create a matching userlist.
</p>
<pre> awk -F: '/^grp/{print "qconf -au ",$4,$1}' /etc/group
</pre>
<h2> <span class="mw-headline" id="qcd"> qcd </span></h2>
<p>If your user's have the same shared file space as the cluster this alias will change directory to the current working directory of the passed in job id.
</p><p>It has to be an alias (or sourced) in order to affect the current shell. 
</p><p>I use the tcsh, and that is why there is all of the bizarre back slashing.
</p><p>Add the line below to the system shell startup file or ~/.tcshrc
</p>
<pre># tcsh:
alias qcd cd\ \`qstat\ -j\ \!\*\|awk\ \'/^cwd/\{print\ \$2\}\'\`
</pre>
<p>For <code>bash/ksh/zsh</code>, a shell function works well:
</p>
<pre>function qcd {
    cd `qstat -j $1 | awk '/^cwd/{print $2}'`;
}
</pre>
<p>Might could revisit this to make it a little nicer with the new XML format?
</p>
<h2> <span class="mw-headline" id="qavailable_processors"> qavailable_processors </span></h2>
<p>This script just sums up the processors that aren't performing a task.  You will have to change the qstat  options to suite your configuration.
</p>
<pre>#!/bin/sh

qstat -g c -l arch=lx24-amd64 -q all.q | awk 'NR &gt; 2 {sum = sum + $4} END {print sum}'
</pre>
<p><br />
</p>
<h2> <span class="mw-headline" id="qtail"> qtail </span></h2>
<p>The following script will 'tail' the end of the standard output file of the passed in job id.
</p>
<pre>#!/bin/sh

if [ $# -ne 1 ]; then
  echo "Usage:"
  echo "  $0 &lt;sge_job_number&gt;"
  exit
fi

out_path=`qstat -j $1|grep ^stdout_path_list|awk '{print $2}'`

if [ "X$out_path" == "X" ]; then
  exit
fi

if [ $out_path == "/dev/null" ]; then
  echo "Standard output is not available because directed to /dev/null"
  exit
fi

tail -f $out_path
</pre>
<h2> <span class="mw-headline" id="rj:_qsub_wrapper_script"> rj: qsub wrapper script </span></h2>
<p>I created a wrapper script for qsub that allows my users to not need to know the complexity of the cluster configurations or job submission.  I called the wrapper script 'rj' (for run jobs) in order to distinguish it from the collection of 'q*' apps that come with Grid Engine.
</p><p>It has the following features:
</p>
<ul><li> Detects whether the application is checkpointable (with Condor)
</li><li> Detects whether the application is MPI (currently known to work with OpenMPI and possibly MPICH), and then checks and makes sure gets the option to specify number of processors
</li><li> Sets the maximum number of parallel processors to what is available so that the job can be dispatched immediately
</li></ul>
<p>Realize that this is very specific to my setup, and you will need to go through it and edit to match what you want it to do.  It also has a lot of history that should probably be re-written.  Approaching the idea to allowing 'rj' to accept all arguments that 'qsub' accepts and pass through, defaulting or forcing those options that I need to change.
</p><p><br />
</p>
<pre>
#!/bin/bash

# Default
WHOAMI=`whoami`
EMAIL=${WHOAMI}@sjrwmd.com
EXTRA_OPTIONS=&quot;  \
                 -q &quot;'*&amp;!boinc'&quot; \
                 -cwd \
                 -j y \
                 -M ${EMAIL} \
                 -V \
&quot;
PE=mpi
NP_OPTION=0
P_OPTION=0
I_OPTION=0

function usage(){
echo &quot;
rj [-np NUM] [-i INPUT_FILE] [-mb] EXECUTABLE
    # EXECUTABLE runs on appropriate node.

rj -np NUM MPI_EXECUTABLE
     # Runs the MPI parallel MPI_EXECUTABLE on NUM nodes.
     # NUM can be a single number or a range, for example 2-8, would run the
     # MPI_EXECUTABLE on at least 2 processors up to 8 processors.

rj -i INPUT_FILE EXECUTABLE
     # Runs EXECUTABLE with interactive input supplied by INPUT_FILE.

rj [-mb] EXECUTABLE
     # -b Waits for EXECUTABLE to finish (blocks) before returning.
     # -m Sends e-mail at end of job.&quot;
exit 1
}

# Detect the project option -P and the -i option
# Didn't try getopt - suspect wouldn't work since command can have options.
while [ $# -ne 0 ]
do
   case $1 in
        -P) EXTRA_OPTIONS=&quot; $EXTRA_OPTIONS $1 $2 &quot;
            shift
            shift
            P_OPTION=1
           &#160;;;
        -i) EXTRA_OPTIONS=&quot; $EXTRA_OPTIONS $1 $2 &quot;
            shift
            shift
            I_OPTION=1
           &#160;;;
        -np) MAXNP=$2
            max_num_slaves=`qstat -g c -l arch=lx24-amd64 | awk 'NR &gt; 2 {sum = sum + $4} END {print int(sum - 1 - 0.1*sum)}'`
            if [ $MAXNP -gt $max_num_slaves ]; then
              MAXNP=$max_num_slaves
              echo &quot;Number of slaves set to maximum allowable = ${max_num_slaves}.&quot;
            fi
            EXTRA_OPTIONS=&quot; $EXTRA_OPTIONS -pe $PE 1-$MAXNP &quot;
            shift
            shift
            NP_OPTION=1
           &#160;;;
         -b) EXTRA_OPTIONS=&quot; $EXTRA_OPTIONS -sync y &quot;
            shift
           &#160;;;
         -m) EXTRA_OPTIONS=&quot; $EXTRA_OPTIONS -m eas &quot;
            shift
           &#160;;;
         -h|--help) usage
           &#160;;;
         *) break
           &#160;;;
   esac
done

if [ $# -eq 0 ]; then
   usage
fi

full_path=`which $1 2&gt; /dev/null`
if [ &quot;x&quot;${full_path} == &quot;x&quot; ]; then
        echo &quot;Executable $1 not found in any directory in $PATH&quot;
        usage
fi

static=`file -L ${full_path} | grep --count --max-count=1 statically`

condor=`nm ${full_path} 2&gt;&amp;1| grep --count --max-count=1 Condor`

mpi=`nm ${full_path} 2&gt;&amp;1| grep --count --max-count=1 MPI_`
if [ ${mpi} -eq 0 ]; then
    mpi=`ldd ${full_path} 2&gt;&amp;1| grep --count --max-count=1 libmpi`
fi

opteron=`file -L ${full_path} | grep --count --max-count=1 'AMD x86-64'`

APPEND_VAR=&quot;$NP_OPTION$P_OPTION$I_OPTION$static$condor$mpi$opteron&quot;

. ${SGE_ROOT}/default/common/settings.sh

# JOBNAME has to be set AFTER options are processed
JOBNAME=`basename $1`

EXTRA_OPTIONS=&quot;${EXTRA_OPTIONS} -N ${JOBNAME} -o &quot;`pwd`&quot;/${JOBNAME}.out &quot;

case $APPEND_VAR in
    1????0?) echo &quot;&quot;
            echo &quot;You specified multiple processors but the executable is not MPI.&quot;
            echo &quot;&quot;
            usage
           &#160;;;
    0????1?) echo &quot;&quot;
            echo &quot;The executable is MPI, please pass the rj script the -np NUM option.&quot;
            echo &quot;&quot;
            usage
           &#160;;;
    1????1?) qsub ${EXTRA_OPTIONS} \
                 /sjr/beodata/local/bin/parallel_job.sh $*
           &#160;;;
   &#160;???11??) qsub ${EXTRA_OPTIONS} \
                 -ckpt condor_ckpt \
                 /sjr/beodata/local/bin/ckpt_job.sh $*
           &#160;;;
   &#160;??????1) qsub ${EXTRA_OPTIONS} \
                 -l arch=lx24-amd64 \
                 /sjr/beodata/local/bin/vanilla_job.sh $*
           &#160;;;
   &#160;???00??) qsub ${EXTRA_OPTIONS} \
                 /sjr/beodata/local/bin/vanilla_job.sh $*
           &#160;;;
   &#160;???10??) echo &quot;&quot;
            echo &quot;The executable is static, but without Condor.&quot;
            echo &quot;Checkpointing is only available with Condor.&quot;
            echo &quot;Use condor_compile to add the checkpointing libraries.&quot;
            echo &quot;&quot;
            qsub ${EXTRA_OPTIONS} \
                 /sjr/beodata/local/bin/vanilla_job.sh $*
           &#160;;;
    *)      usage
           &#160;;;
esac
</pre>
<p>Required supporting scripts for 'rj':
</p><p>vanilla_job.sh
</p>
<pre>
#!/bin/bash

echo ${JOB_ID} &gt; sge_job_id

: &gt; $SGE_STDOUT_PATH

#$ -S /bin/bash
$*
</pre>
<p>parallel_job.sh
</p>
<pre>
#!/bin/bash

echo ${JOB_ID} &gt; sge_job_id

: &gt; $SGE_STDOUT_PATH

#$ -S /bin/bash

mpirun -np $NSLOTS $*
</pre>
<p>ckpt_job.sh
</p>
<pre>
#!/bin/bash

#$ -S /bin/bash

cd $PWD

echo ${JOB_ID} &gt; sge_job_id

: &gt; $SGE_STDOUT_PATH

CHECKPOINT_DIR=&quot;/sjr/beodata/tmp/ckpt&quot;
OUTPUT=&quot;${CHECKPOINT_DIR}/${JOB_ID}.log&quot;

echo &quot;-------------------------------------&quot; &gt;&gt; $OUTPUT
if [ ${RESTARTED} -eq 0 ];
then
        echo &quot;      Starting job #${JOB_ID}&quot;         &gt;&gt; $OUTPUT
        $1 -_condor_ckpt ${CHECKPOINT_DIR}/${JOB_ID}.ckpt $@ &amp;
else
        echo &quot;      Re-Starting job #${JOB_ID}&quot;      &gt;&gt; $OUTPUT
        $1 -_condor_restart ${CHECKPOINT_DIR}/${JOB_ID}.ckpt &amp;
fi

PROC_PID=$!
echo $! &gt; ${CHECKPOINT_DIR}/${JOB_ID}.pid

echo &quot;-------------------------------------&quot; &gt;&gt; $OUTPUT
echo &quot; Date:     `date`&quot;                     &gt;&gt; $OUTPUT
echo &quot; Job PID:  ${PROC_PID}&quot;                &gt;&gt; $OUTPUT
echo &quot; Hostname: `hostname`&quot;                 &gt;&gt; $OUTPUT
echo &quot;-------------------------------------&quot; &gt;&gt; $OUTPUT
wait
</pre>
<h2> <span class="mw-headline" id="User_Job_Stats"> User Job Stats </span></h2>
<p>I created this script to automate some monthly reporting I was required to do.
It's features are;
</p>
<ul><li> Display figures for the week, month or year to date, or for the specified number of days
</li><li> Display total cluster usage, globally and for each user
</li><li> Display average cluster usage, for each user and the usage of the 'average' job across the whole cluster
</li></ul>
<p>It has a help function with usage examples, but if anyone needs pointers feel free to drop me a line.
</p><p>NB: To determine which users have actually logged on to the cluster, it gets a list of home directories from the path specified by 'HOME_DIR_LOCATION'. You may need to alter the value of this variable to suit your system for the script to work.
</p>
<pre>
#!/bin/bash
#
#==========================================================================
# Name: User SGE Job Statistics
# Author: Chris Bingham
# Date: 11.11.2008
# Language: Bash
# External References: ls, qacct, grep, cut, expr, getent, tr, date, qconf
#
# This script will use the SGE command 'qacct' to search back though all the
# job records for the specified number of days, and return a table of
# statistics for each user's usage of the cluster, sorted highest to lowest.
#==========================================================================

# Global Variables
HOME_DIR_LOCATION=&quot;/home&quot;

# Store the first two arguments, all other arguments will be discarded
DAYS=$1
TOTAL=$2

function display_help() {
	# Display a help message
	echo &quot;---User SGE Job Statistics---&quot;
	echo &quot;This script will use the SGE command 'qacct' to search back though all the&quot;
	echo &quot;job records for the specified number of days, and return a table of statistics&quot;
	echo &quot;for each user's usage of the cluster, sorted highest to lowest.&quot;
	echo &quot;&quot;
	echo &quot;--Usage--&quot;
	echo -e &quot;  user_job_stats.sh [DAYS|OPTION] [total]&quot;
	echo -e &quot;  Where 'DAYS' is a number of days to gather statistics for or 'OPTION' is one of the following;&quot;
	echo -e &quot;  \tweek\t\t\tGather statistics for the week so far&quot;
	echo -e &quot;  \tmonth\t\t\tGather statistics for the month to date&quot;
	echo -e &quot;  \tyear\t\t\tGather statistics for the year to date&quot;
	echo -e &quot;  \thelp\t\t\tDisplay this message&quot;
	echo -e &quot;  Specifying 'total' at the end of the line will generate total usage statistics rather than average usage statistics&quot;
	echo &quot;&quot;
	echo &quot;--Usage Examples--&quot;
	echo -e &quot;  user_job_stats.sh 10\t\tGet average statistics for the last 10 days&quot;
	echo -e &quot;  user_job_stats.sh 10 total\tGet total statistics for the last 10 days&quot;
	echo -e &quot;  user_job_stats.sh month\tGet average statistics for the month to date&quot;
	echo -e &quot;  user_job_stats.sh week total\tGet total statistics for the week to date&quot;
	echo &quot;&quot;
	echo &quot;--Definitions--&quot;
	echo -e &quot;  CPU Time\t\t\tThe amount of time for which jobs were using CPU resources, measured using SGE's 'cpu' metric from 'qacct'&quot;
	echo -e &quot;  Wallclock Time\t\tThe amount of time for which jobs were running.&quot;
	echo -e &quot; &#160;% of Wallclock Time\t\tThe percentage of the cluster's overall total available wallclock time used.&quot;
	echo -e &quot;  \t\t\t\tTotal available wallclock time is calculated as: DAYS * Number of CPUs in Cluster&quot;
}

function averages_or_totals() {
	# Determine if the user request totals or averages
	if [ &quot;$TOTAL&quot; = &quot;total&quot; ]&#160;; then
		gen_totals
	elif [ -z &quot;$TOTAL&quot; ]&#160;; then
		gen_averages
	else
		display_help
	fi
}

function gen_human_readable_time() {
	# Convert a time in seconds into a more human-friendly scale (hours, days etc instead of seconds)
	
	# If the time span is less than 1 hour, convert to minutes
	if [ &quot;$TIME&quot; -lt &quot;3600&quot; ]&#160;; then
		TIME=`echo &quot;scale=2; $TIME/60&quot; | bc`
		TIME=&quot;$TIME minutes&quot;
	# If the time span is less than 1 day, convert to hours
	elif [ &quot;$TIME&quot; -lt &quot;86400&quot; ]&#160;; then
		TIME=`echo &quot;scale=2; $TIME/3600&quot; | bc`
		TIME=&quot;$TIME hours&quot;
	# If the time span is less than 1 week, convert to days
	elif [ &quot;$TIME&quot; -lt &quot;604800&quot; ]&#160;; then
		TIME=`echo &quot;scale=2; $TIME/86400&quot; | bc`
		TIME=&quot;$TIME days&quot;
	# If the time span is less than 1 year, convert to weeks
	elif [ &quot;$TIME&quot; -lt &quot;31449600&quot; ]&#160;; then
		TIME=`echo &quot;scale=2; $TIME/604800&quot; | bc`
		TIME=&quot;$TIME weeks&quot;
	# If the time span is 1 year or more, convert to years
	else
		TIME=`echo &quot;scale=2; $TIME/31449600&quot; | bc`
		TIME=&quot;$TIME years&quot;
	fi
}

function get_userlist() {
	# Get a list of usernames by listing the home directories
	USER_LIST=`ls $HOME_DIR_LOCATION`
}

function calc_cpu_wallclock() {
	# Calculate the total amount of available cluster time during the specified number of days
	# Get a count of the numbe rof execution hosts from SGE
	CPU_COUNT=`qconf -sep | grep -i sum | tr -d [:alpha:][:space:]`
	
	# Calculate the total amount of wallclock for all nodes in seconds
	CPU_WALLCLOCK=$(($CPU_COUNT * $DAYS * 24 * 60 * 60))
	# Calculate 1% of the total cluster wallclock (for later use)
	CPU_WALLCLOCK_100=`expr $CPU_WALLCLOCK / 100`
}

function gen_totals() {

	# Call 'get_userlist' to get a user name list
	get_userlist
	
	# Get the total amount of available cluster time during the specified number of days
	calc_cpu_wallclock
	
	# Reset the total counters to zero
	TOTAL_PERCENT_CPU_WALLCLOCK=&quot;0&quot;
	TOTAL_CPU_WALLCLOCK=&quot;0&quot;
	TOTAL_CLUSTER_CPUTIME=&quot;0&quot;
	TOTAL_JOB_COUNT=&quot;0&quot;

	# For each username found, do the following;
	for i in $USER_LIST&#160;; do
		
		# Use 'qacct' and 'grep' to count the total number of jobs they've submitted
		USER_USER_JOB_COUNT=`qacct -o &quot;$i&quot; -j -d $DAYS | grep &quot;jobname&quot; -c`
		TOTAL_JOB_COUNT=`expr $TOTAL_JOB_COUNT + $USER_USER_JOB_COUNT`
		
		# If the user has submitted no jobs, record their utilisation as zero,
		# else, use 'qacct', 'grep' and 'cut' to get an array of the wallclock and CPU time
		# counters for all of their jobs
		if [ &quot;$USER_USER_JOB_COUNT&quot; = &quot;0&quot; ]&#160;; then
			USER_TOTAL_WALLCLOCK=&quot;0&quot;
			USER_TOTAL_CPUTIME=&quot;0&quot;
			USER_PERCENT_CPU_WALLCLOCK=&quot;0&quot;
		else
			USER_TOTAL_WALLCLOCK=`qacct -o &quot;$i&quot; -d $DAYS | grep &quot;$i&quot; | tr -s &quot; &quot; &quot;\t&quot; | cut -f 2`
			USER_TOTAL_CPUTIME=`qacct -o &quot;$i&quot; -d $DAYS | grep &quot;$i&quot; | tr -s &quot; &quot; &quot;\t&quot; | cut -f 5`
			USER_PERCENT_CPU_WALLCLOCK=`echo &quot;scale=2; $USER_TOTAL_WALLCLOCK/$CPU_WALLCLOCK_100&quot; | bc`
		fi
		
		if [ -z &quot;$USER_TOTAL_WALLCLOCK&quot; ] &#160;; then
			USER_TOTAL_WALLCLOCK=&quot;0&quot;
			USER_PERCENT_CPU_WALLCLOCK=&quot;0&quot;
		fi
		
		if [ -z &quot;$USER_TOTAL_CPUTIME&quot; ]&#160;; then
			USER_TOTAL_CPUTIME=&quot;0&quot;
			USER_PERCENT_CPU_WALLCLOCK=&quot;0&quot;
		fi
		
		# Add this user's percentage of cluster time consumed to the total
		TOTAL_PERCENT_CPU_WALLCLOCK=`echo &quot;scale=2; $TOTAL_PERCENT_CPU_WALLCLOCK+$USER_PERCENT_CPU_WALLCLOCK&quot; | bc`
		TOTAL_CPU_WALLCLOCK=`echo &quot;scale=2; $TOTAL_CPU_WALLCLOCK+$USER_TOTAL_WALLCLOCK&quot; | bc`
		TOTAL_CLUSTER_CPUTIME=`echo &quot;scale=2; $TOTAL_CLUSTER_CPUTIME+$USER_TOTAL_CPUTIME&quot; | bc`
		
		# Convert the user's username into their actual name
		USERNAME=`getent passwd &quot;$i&quot; | cut -d &quot;:&quot; -f 5`
		
		# If the passwd file didn't contain the user's actual name, use their username
		if [ -z &quot;$USERNAME&quot; ]&#160;; then
			USERNAME=&quot;$i&quot;
		fi
		
		# Start the output string
		OUT=&quot;$OUT$USER_PERCENT_CPU_WALLCLOCK \t\t\t&quot;
		
		# If the average wallclock and CPU time are less than a millon, add an extra tab
		# after them to improve the readability of the output table
		if [ &quot;$USER_TOTAL_WALLCLOCK&quot; -ge &quot;1000000&quot; ]&#160;; then
			OUT=&quot;$OUT$USER_TOTAL_WALLCLOCK \t\t&quot;
		else
			OUT=&quot;$OUT$USER_TOTAL_WALLCLOCK \t\t\t&quot;
		fi
		
		if [ &quot;$USER_TOTAL_CPUTIME&quot; -ge &quot;1000000&quot; ]&#160;; then
			OUT=&quot;$OUT$USER_TOTAL_CPUTIME \t$USER_USER_JOB_COUNT \t\t\t$USERNAME \n&quot;
		else
			OUT=&quot;$OUT$USER_TOTAL_CPUTIME \t\t$USER_USER_JOB_COUNT \t\t\t$USERNAME \n&quot;
		fi
		
		# Clean up all variables for the next loop
		USER_USER_JOB_COUNT=&quot;&quot;
		USER_TOTAL_WALLCLOCK=&quot;&quot;
		USER_TOTAL_CPUTIME=&quot;&quot;
		USER_PERCENT_CPU_WALLCLOCK=&quot;&quot;
		USERNAME=&quot;&quot;
	done
	
	# Output the results table, performing a reverse-numerical sort on the results
	echo -e &quot;% of Wallclock Time\tTotal Wallclock Time\tTotal CPU Time\tTotal Number of Jobs\tUser Name&quot;
	echo &quot;-------------------------------------------------------------------------------------------------&quot;
	echo -e $OUT | sort -nr
	echo &quot;-------------------------------------------------------------------------------------------------&quot;
	
	# Calculate the percentage of time the cluster was idle for
	CLUSTER_IDLE=`echo &quot;scale=2; 100-$TOTAL_PERCENT_CPU_WALLCLOCK&quot; | bc`
	
	# Convert the total wallclock time in to a human-readable form
	TIME=&quot;$TOTAL_CPU_WALLCLOCK&quot;
	gen_human_readable_time
	TOTAL_CPU_WALLCLOCK=&quot;$TIME&quot;
	
	# Convert the total CPU time in to a human-readable form
	TIME=&quot;$TOTAL_CLUSTER_CPUTIME&quot;
	gen_human_readable_time
	TOTAL_CLUSTER_CPUTIME=&quot;$TIME&quot;
	
	# Output overall cluster utilisation statistics
	echo &quot;$TOTAL_JOB_COUNT jobs used $TOTAL_CPU_WALLCLOCK of Wallclock Time and $TOTAL_CLUSTER_CPUTIME of CPU Time have been used during the last $DAYS days, and the cluster was $CLUSTER_IDLE% idle.&quot;
}

function gen_averages() {

	# Call 'get_userlist' to get a user name list
	get_userlist
	
	# For each username found, do the following;
	for i in $USER_LIST&#160;; do
		
		# Use 'qacct' and 'grep' to count the total number of jobs they've submitted
		USER_JOB_COUNT=`qacct -o &quot;$i&quot; -j -d $DAYS | grep &quot;jobname&quot; -c`
		
		# Add the user's job count to the overall total
		TOTAL_JOB_COUNT=`expr $TOTAL_JOB_COUNT + $USER_JOB_COUNT`
		
		# If the user has submitted no jobs, record their utilisation as zero,
		# else, use 'qacct', 'grep' and 'cut' to get an array of the wallclock and CPU time
		# counters for all of their jobs
		if [ &quot;$USER_JOB_COUNT&quot; = &quot;0&quot; ]&#160;; then
			USER_JOB_WALLCLOCKS=&quot;0&quot;
			USER_JOB_CPUTIMES=&quot;0&quot;
		else
			USER_JOB_WALLCLOCKS=`qacct -o &quot;$i&quot; -j -d $DAYS |  grep &quot;wallclock &quot; | cut -d &quot; &quot; -f 2`
			USER_JOB_CPUTIMES=`qacct -o &quot;$i&quot; -j -d $DAYS | grep &quot;cpu &quot; | cut -c 14-100`
		fi
		
		# Set 'COUNT' to zero
		COUNT=&quot;0&quot;
		
		# If the user's utilisation isn't zero, calculate their average wallclock time
		if [ &quot;$USER_JOB_WALLCLOCKS&quot;&#160;!= &quot;0&quot; ]&#160;; then
			for a in $USER_JOB_WALLCLOCKS&#160;; do
				
				USER_TOTAL_WALLCLOCK=`expr $USER_TOTAL_WALLCLOCK + $a`
				COUNT=`expr $COUNT + 1`
				
			done
			
			# Add the user's total wallclock time to the overall total
			TOTAL_JOB_WALLCLOCK=`expr $TOTAL_JOB_WALLCLOCK + $USER_TOTAL_WALLCLOCK`
			
			USER_AVG_JOB_WALLCLOCK=`expr $USER_TOTAL_WALLCLOCK / $COUNT`
		else
			USER_AVG_JOB_WALLCLOCK=&quot;0&quot;
		fi
			
		# Set 'COUNT' to zero
		COUNT=&quot;0&quot;
		
		# If the user's utilisation isn't zero, calculate their average CPU time
		if [ &quot;$USER_JOB_CPUTIMES&quot;&#160;!= &quot;0&quot; ]&#160;; then
			for b in $USER_JOB_CPUTIMES&#160;; do
				
				USER_TOTAL_CPUTIME=`expr $USER_TOTAL_CPUTIME + $b`
				COUNT=`expr $COUNT + 1`
				
			done
			
			# Add the user's total CPU time to the overall total
			TOTAL_JOB_CPUTIME=`expr $TOTAL_JOB_CPUTIME + $USER_TOTAL_CPUTIME`
			
			USER_AVG_JOB_CPUTIME=`expr $USER_TOTAL_CPUTIME / $COUNT`
		else
			USER_AVG_JOB_CPUTIME=&quot;0&quot;
		fi
		
		# Convert the user's username into their actual name
		USERNAME=`getent passwd &quot;$i&quot; | cut -d &quot;:&quot; -f 5`
		
		# If the passwd file didn't contain the user's actual name, use their username
		if [ -z &quot;$USERNAME&quot; ]&#160;; then
			USERNAME=&quot;$i&quot;
		fi
		
		# If the average wallclock and CPU time are less than a million, add an extra tab
		# after them to improve the readability of the output table
		if [ &quot;$USER_AVG_JOB_WALLCLOCK&quot; -ge &quot;1000000&quot; ]&#160;; then
			OUT=&quot;$OUT$USER_AVG_JOB_WALLCLOCK \t\t\t&quot;
		else
			OUT=&quot;$OUT$USER_AVG_JOB_WALLCLOCK \t\t\t\t&quot;
		fi
		
		if [ &quot;$USER_AVG_JOB_CPUTIME&quot; -ge &quot;1000000&quot; ]&#160;; then
			OUT=&quot;$OUT$USER_AVG_JOB_CPUTIME \t\t$USER_JOB_COUNT \t\t\t$USERNAME \n&quot;
		else
			OUT=&quot;$OUT$USER_AVG_JOB_CPUTIME \t\t\t$USER_JOB_COUNT \t\t\t$USERNAME \n&quot;
		fi
		
		# Clean up all variables for the next loop
		USER_JOB_COUNT=&quot;&quot;
		USER_JOB_WALLCLOCKS=&quot;&quot;
		USER_JOB_CPUTIMES=&quot;&quot;
		COUNT=&quot;&quot;
		USER_TOTAL_WALLCLOCK=&quot;&quot;
		USER_TOTAL_CPUTIME=&quot;&quot;
		USER_AVG_JOB_WALLCLOCK=&quot;&quot;
		USER_AVG_JOB_CPUTIME=&quot;&quot;
		USERNAME=&quot;&quot;
	done
	
	# Output the results table, performing a reverse-numerical sort on the results
	echo -e &quot;Average Wallclock Time/Job\tAverage CPU Time/Job\tTotal Number of Jobs\tUser Name&quot;
	echo &quot;-------------------------------------------------------------------------------------------&quot;
	echo -e $OUT | sort -nr
	echo &quot;-------------------------------------------------------------------------------------------&quot;
	
	# If the total job count is 0, record all overall averages as 0, otherwise calculate them
	if [ &quot;$TOTAL_JOB_COUNT&quot; = &quot;0&quot; ]&#160;; then
		TOTAL_AVG_JOB_WALLCLOCK=&quot;0&quot;
		TOTAL_AVG_JOB_CPUTIME=&quot;0&quot;
	else
		TOTAL_AVG_JOB_WALLCLOCK=`expr $TOTAL_JOB_WALLCLOCK / $TOTAL_JOB_COUNT`
		TOTAL_AVG_JOB_CPUTIME=`expr $TOTAL_JOB_CPUTIME / $TOTAL_JOB_COUNT`
	fi
	
	# Calculate average job idle time
	TOTAL_AVG_JOB_IDLE=`echo &quot;scale=2; 100-(($TOTAL_AVG_JOB_CPUTIME/$TOTAL_AVG_JOB_WALLCLOCK)*100)&quot; | bc`
	
	# Convert the total wallclock time in to a human-readable form
	TIME=&quot;$TOTAL_AVG_JOB_WALLCLOCK&quot;
	gen_human_readable_time
	TOTAL_AVG_JOB_WALLCLOCK=&quot;$TIME&quot;
	
	# Convert the total CPU time in to a human-readable form
	TIME=&quot;$TOTAL_AVG_JOB_CPUTIME&quot;
	gen_human_readable_time
	TOTAL_AVG_JOB_CPUTIME=&quot;$TIME&quot;
	
	# Output the overall average job statistics
	echo &quot;The average job during the last $DAYS days took $TOTAL_AVG_JOB_WALLCLOCK to complete, consumed $TOTAL_AVG_JOB_CPUTIME of CPU Time and was idle for $TOTAL_AVG_JOB_IDLE% of the time.&quot;
}

# Check if the first argument was null, and display help and exit if so
if [ -z &quot;$DAYS&quot; ]&#160;; then
	display_help
	exit
else
	# Else, select from the following options
	case &quot;$DAYS&quot; in
		&quot;week&quot;)
			# If 'week' is specified, determine how many days into the week we are, starting from, Monday
			DAYS=`date +%u`
			averages_or_totals
			;;
		&quot;month&quot;)
			# If 'month' is specified, determine how many days into the month we are
			DAYS=`date +%d`
			averages_or_totals
			;;
		&quot;year&quot;)
			# If 'year' is specified, determine how many days into the year we are
			DAYS=`date +%j`
			averages_or_totals
			;;
		(*[0-9])
			# Otherwise, if the input conatains numbers, trim out all non-numeric characters and continue
			DAYS=`echo $DAYS | tr -d [:alpha:][:punct:]`
			averages_or_totals
			;;
		&quot;help&quot;)
			# If 'help' is specified, display the help message and exit
			display_help
			exit
			;;
		*)
			# If the input is anything else, display the help message and exit
			display_help
			exit
			;;
	esac
fi
</pre>
<h2> <span class="mw-headline" id="qtime"> qtime </span></h2>
<p>This script was written to allow people to get an idea of how long their job might have to wait to be executed at any given time. It iterates though all completed jobs from the given time period (week, month or year to date, or a number of days) and calculates the minimum, maximum and average wait times.
</p><p>On one system I've worked on the average wait time over a month was used as a measurement of system performance in the SLA, with this script providing the figures.
</p><p>Again, it has a help function with usage examples, but if anyone need pointers feel free to drop me a line.
</p>
<pre>
#!/bin/bash
#
#==========================================================================
# Name: Average Queuing Time
# Author: Chris Bingham
# Date: 12.02.2009
# Language: Bash
# External References: qacct, grep, cut, bc
#
# This script will calculate the average time jobs have had to spent
# queuing before being run over the specified time period
#==========================================================================

# Store the first argument
DAYS=&quot;$1&quot;

function display_help() {
	# Display a help message
	echo &quot;---Average Queuing Time---&quot;
	echo &quot;This script will calculate the average time jobs have had to spent&quot;
	echo &quot;queuing before being run over the specified time period&quot;
	echo &quot;&quot;
	echo &quot;--Usage--&quot;
	echo -e &quot;  qtime.sh [DAYS|OPTION]&quot;
	echo -e &quot;  Where 'DAYS' is a number of days to calculate the average for or 'OPTION' is one of the following;&quot;
	echo -e &quot;  \tweek\t\t\tCalculate the average for the week so far&quot;
	echo -e &quot;  \tmonth\t\t\tCalculate the average for the month to date&quot;
	echo -e &quot;  \tyear\t\t\tCalculate the average for the year to date&quot;
	echo -e &quot;  \thelp\t\t\tDisplay this message&quot;
}

function gen_human_readable_time() {
	# Convert a time in seconds into a more human-friendly scale (hours, days etc instead of seconds)
	
	# If the time span is less than 1 hour, convert to minutes
	if [ &quot;$TIME_INT&quot; -lt &quot;60&quot; ]&#160;; then
		TIME=&quot;$TIME seconds&quot;
	elif [ &quot;$TIME_INT&quot; -lt &quot;3600&quot; ]&#160;; then
		TIME=`echo &quot;scale=2; $TIME/60&quot; | bc`
		TIME=&quot;$TIME minutes&quot;
	# If the time span is less than 1 day, convert to hours
	elif [ &quot;$TIME_INT&quot; -lt &quot;86400&quot; ]&#160;; then
		TIME=`echo &quot;scale=2; $TIME/3600&quot; | bc`
		TIME=&quot;$TIME hours&quot;
	# If the time span is less than 1 week, convert to days
	elif [ &quot;$TIME_INT&quot; -lt &quot;604800&quot; ]&#160;; then
		TIME=`echo &quot;scale=2; $TIME/86400&quot; | bc`
		TIME=&quot;$TIME days&quot;
	# If the time span is less than 1 year, convert to weeks
	elif [ &quot;$TIME_INT&quot; -lt &quot;31449600&quot; ]&#160;; then
		TIME=`echo &quot;scale=2; $TIME/604800&quot; | bc`
		TIME=&quot;$TIME weeks&quot;
	# If the time span is 1 year or more, convert to years
	else
		TIME=`echo &quot;scale=2; $TIME/31449600&quot; | bc`
		TIME=&quot;$TIME years&quot;
	fi
}

function calc_avg() {
	# Set the field seperator for array creation to a new line
	OLDIFS=$IFS
	IFS=$'\n'
	
	# Get information for SGE using the 'qacct' command, storing submit and start times in arrays
	USER_JOB_COUNT=`qacct -j -d $DAYS | grep &quot;jobname&quot; -c`
	USER_SUBMIT_TIMES=($(qacct -j -d $DAYS | grep &quot;qsub_time&quot; | cut -d &quot; &quot; -f 5-9))
	USER_START_TIMES=($(qacct -j -d $DAYS | grep &quot;start_time&quot; | cut -d &quot; &quot; -f 4-9))
	
	# Get the length of one of the arrays
	USER_SUBMIT_TIMES_COUNT=${#USER_SUBMIT_TIMES[@]}
	
	# Reset the field seperator to it's previous value
	IFS=$OLDIFS

	# Create variables to store min and max wait times
	MIN_WAIT_TIME=&quot;&quot;
	MAX_WAIT_TIME=&quot;&quot;
	
	# Determine if any jobs have been completed ov the specified time period
	if [ &quot;$USER_SUBMIT_TIMES_COUNT&quot; -gt &quot;0&quot; ]&#160;; then
		# If yes, then calculate the average wait time
		
		# For each element in the arrays, do the following;
		for (( i=0; i&lt;${USER_SUBMIT_TIMES_COUNT}; i++ ))&#160;; do
			# Convert the submit and start time to seconds since the epoch
			SUBMIT_SECONDS=`date -d &quot;${USER_SUBMIT_TIMES[$i]}&quot; +%s`
			START_SECONDS=`date -d &quot;${USER_START_TIMES[$i]}&quot; +%s`
			
			# Calculate how long the job was queuing, and add this to the total queuing time
			WAIT_TIME=$(($START_SECONDS-$SUBMIT_SECONDS))
			TOTAL_WAIT_TIME=$((TOTAL_WAIT_TIME+$WAIT_TIME))
			
			if [ -z &quot;$MIN_WAIT_TIME&quot; ]&#160;; then
				MIN_WAIT_TIME=$WAIT_TIME
				MAX_WAIT_TIME=$WAIT_TIME
			else
				if [ &quot;$MIN_WAIT_TIME&quot; -gt &quot;$WAIT_TIME&quot; ]&#160;; then
					MIN_WAIT_TIME=$WAIT_TIME
				fi
				if [ &quot;$MAX_WAIT_TIME&quot; -lt &quot;$WAIT_TIME&quot; ]&#160;; then
					MAX_WAIT_TIME=$WAIT_TIME
				fi
			fi
			
			# Reset all variables for the next iteration of the loop
			WAIT_TIME=&quot;&quot;
			SUBMIT_SECONDS=&quot;&quot;
			START_SECONDS=&quot;&quot;
		done
		
		# Calculate the average queuing time as both an integer and floating point number
		AVG_WAIT_TIME=`echo &quot;scale=2; $TOTAL_WAIT_TIME/$USER_SUBMIT_TIMES_COUNT&quot; | bc`
		AVG_WAIT_TIME_INT=$(($TOTAL_WAIT_TIME/$USER_SUBMIT_TIMES_COUNT))
		
		TIME_INT=$AVG_WAIT_TIME_INT
		TIME=$AVG_WAIT_TIME
		
		gen_human_readable_time
		
		AVG_WAIT_TIME=$TIME
		
		TIME_INT=$MIN_WAIT_TIME
		TIME=$MIN_WAIT_TIME
		
		gen_human_readable_time
		
		MIN_WAIT_TIME=$TIME
		
		TIME_INT=$MAX_WAIT_TIME
		TIME=$MAX_WAIT_TIME
		
		gen_human_readable_time
		
		MAX_WAIT_TIME=$TIME
		
		# Display the average queuing time
		echo &quot;&quot;
		echo &quot;During the last $DAYS days, jobs had to queue (wait to be run) for;&quot;
		echo -e &quot;\tOn average:\t$AVG_WAIT_TIME&quot;
		echo -e &quot;\tAt least:\t$MIN_WAIT_TIME&quot;
		echo -e &quot;\tAt most:\t$MAX_WAIT_TIME&quot;
		echo &quot;&quot;
	else
		# If no, then display the wait time as 0 seconds
		echo &quot;&quot;
                echo &quot;During the last $DAYS days, jobs had to queue (wait to be run) for;&quot;
                echo -e &quot;\tOn average:\t0 seconds&quot;
                echo -e &quot;\tAt least:\t0 seconds&quot;
                echo -e &quot;\tAt most:\t0 seconds&quot;
                echo &quot;&quot;

	fi
}

# Check first argument
case &quot;$DAYS&quot; in
	&quot;week&quot;)
		# If 'week' is specified, determine how many days into the week we are, starting from, Monday
		DAYS=`date +%u`
		calc_avg
		;;
	&quot;month&quot;)
		# If 'month' is specified, determine how many days into the month we are
		DAYS=`date +%d`
		calc_avg
		;;
	&quot;year&quot;)
		# If 'year' is specified, determine how many days into the year we are
		DAYS=`date +%j`
		calc_avg
		;;
	(*[0-9])
		# If the input conatains numbers, trim out all non-numeric characters and continue
		DAYS=`echo $DAYS | tr -d [:alpha:][:punct:]`
		calc_avg
		;;
	&quot;help&quot;)
		# If 'help' is specified, display the help message and exit
		display_help
		exit
		;;
	*)
		# If the input is anything else, display the help message and exit
		display_help
		exit
		;;
esac
</pre>
<h2> <span class="mw-headline" id="Queue_Job_Count"> Queue Job Count </span></h2>
<p>This one's quite simple - it determines what queues exist on the cluster, then counts up how many jobs have been submitted to each one over the specified period (week, month or year to date, or a number of days).
</p>
<pre>
#!/bin/bash
#
#==========================================================================
# Name: SGE Queue Job Count
# Author: Chris Bingham
# Date: 28.11.2008
# Language: Bash
# External References: qconf, qacct, grep, date, tr
#
# This script will use the SGE command 'qconf' to get a list of queues
# configured on the cluster, then use 'qacct' to search back though job
# records for each queue for the specified number of days, and return a
# table of jobs counts for each queue, sorted highest to lowest
#==========================================================================

# Store the first argument, all other argument will be discarded
DAYS=$1

# Use 'qacct' to get a list of queues, and convert it to an array
QUEUE_LIST=`qconf -sql`
QUEUE_LIST=`echo $QUEUE_LIST | tr -t ' ' &quot; &quot; `

# Create a variable to store the total job count
TOTAL_JOB_COUNT=&quot;0&quot;

function get_job_count() {
	# For each queue found, do the following;
	for q in `echo -e $QUEUE_LIST`&#160;; do
	
		# Use 'qacct' and 'grep' to get a count of the number of jobs for the
		# specified time period
		QUEUE_JOB_COUNT=`qacct -d $DAYS -q $q -j | grep &quot;qname        $q&quot; -c`
		
		# Add this to the total job count		
		TOTAL_JOB_COUNT=$(($TOTAL_JOB_COUNT+$QUEUE_JOB_COUNT))

		# Store the results for later output
		OUT=&quot;$OUT$QUEUE_JOB_COUNT\t\t$q\n&quot;
	done
	
	# Output the results table, performing a reverse-numerical sort on the results
	echo -e &quot;Job Count\tQueue&quot;
	echo &quot;--------------------------&quot;
	echo -e $OUT | sort -nr
	echo &quot;Total Job Count: $TOTAL_JOB_COUNT&quot;
}



function display_help() {
	# Display a help message
	echo &quot;---SGE Queue Job Count---&quot;
	echo &quot;This script will use the SGE command 'qacct' to search back though all the&quot;
	echo &quot;job records for the specified number of days, and return a table of the&quot;
	echo &quot;job counts for each queue configured on the system.&quot;
	echo &quot;&quot;
	echo &quot;Usage: q_job_count.sh [DAYS|OPTION]&quot;
	echo &quot;Where 'DAYS' is a number of days to gather statistics for or 'OPTION' is one of the following;&quot;
	echo -e &quot;\tweek\tGather statistics for the week so far&quot;
	echo -e &quot;\tmonth\tGather statistics for the month to date&quot;
	echo -e &quot;\tyear\tGather statistics for the year to date&quot;
	echo -e &quot;\thelp\tDisplay this message&quot;
}


# Check if the first argument was null, and display help and exit if so
if [ -z &quot;$DAYS&quot; ]&#160;; then
	display_help
	exit
else
	# Else, select from the following options
	case &quot;$DAYS&quot; in
		&quot;week&quot;)
			# If 'week' is specified, determine how many days into the week we are, starting from, Monday
			DAYS=`date +%u`
			get_job_count
			;;
		&quot;month&quot;)
			# If 'month' is specified, determine how many days into the month we are
			DAYS=`date +%d`
			get_job_count
			;;
		&quot;year&quot;)
			# If 'year' is specified, determine how many days into the year we are
			DAYS=`date +%j`
			get_job_count
			;;
		(*[0-9])
			# Otherwise, if the input conatains numbers, trim out all non-numeric characters and continue
			DAYS=`echo $DAYS | tr -d [:alpha:][:punct:]`
			get_job_count
			;;
		&quot;help&quot;)
			# If 'help' is specified, display the help message and exit
			display_help
			exit
			;;
		*)
			# If the input is anything else, display the help message and exit
			display_help
			exit
			;;
	esac
fi
</pre>
<h2> <span class="mw-headline" id="Change_Queue_State"> Change Queue State </span></h2>
<p>A very short script that will either enable or disable all queue instances on the host its run on - I've found it useful for quickly knocking out the queues on nodes that are being taken down for maintenance.
</p>
<pre>
#!/bin/bash
#
#==========================================================================
# Name: Change SGE Queue Instance States
# Author: Chris Bingham
# Date: 28.11.2008
# Language: Bash
# External References: qselect, qmod, grep, tr
#
# This script will, based on the argument supplied, either enable or disable
# all queue instances on the current host
#==========================================================================

# Store the first argument, all other argument will be discarded
ACTION=$1

# Convert any uppercase letters to lowercase, for the case statement below
ACTION=`echo $ACTION | tr -t [:upper:] [:lower:]`

# Determine what action to take based on the argument supplied
case &quot;$ACTION&quot; in
	&quot;enable&quot;)
		# If the argument was 'enable', then use 'qselect' and 'grep' to select all
		# queue instances on the current host (except 'test.q') and then enable them
		# using 'qmod'
		qmod -e `qselect -q *@$HOSTNAME`
		;;
	&quot;disable&quot;)
		# If the argument was 'disable', then use 'qselect' and 'grep' to select all
		# queue instances on the current host (except 'test.q') and then disable them
		# using 'qmod'
		qmod -d `qselect -q *@$HOSTNAME`
		;;
	*)
		# If the argument was anything else, display an error message
		echo &quot;Invalid option: please enter either 'enable' or 'disable'&quot;
		;;
esac
</pre>
<h2> <span class="mw-headline" id="filter-accounting"> filter-accounting </span></h2>
<p>A small Perl script to filter the accounting file by the end_time of the jobs.
Mostly useful for splitting up an accounting file by years, for example.
</p>
<ul><li> <a href="/wiki/images/6/65/Filter-accounting.txt" class="internal" title="Filter-accounting.txt"> filter-accounting</a>
</li></ul>
<h2> <span class="mw-headline" id="Other_Miscellaneous"> Other Miscellaneous </span></h2>
<p>Some others, partially overlapping with some above are listed under
<a rel="nofollow" class="external free" href="http://www.nw-grid.ac.uk/LivScripts">http://www.nw-grid.ac.uk/LivScripts</a>.
</p>
<!-- 
NewPP limit report
Preprocessor node count: 130/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key gridwikidb-grid_:pcache:idhash:1834-0!*!0!!en!*!* and timestamp 20140701123424 -->
</div>				<!-- /bodycontent -->
								<!-- printfooter -->
				<div class="printfooter">
				Retrieved from "<a href="http://wiki.gridengine.info/wiki/index.php?title=Utilities&amp;oldid=5193">http://wiki.gridengine.info/wiki/index.php?title=Utilities&amp;oldid=5193</a>"				</div>
				<!-- /printfooter -->
												<!-- catlinks -->
				<div id='catlinks' class='catlinks catlinks-allhidden'></div>				<!-- /catlinks -->
												<div class="visualClear"></div>
				<!-- debughtml -->
								<!-- /debughtml -->
			</div>
			<!-- /bodyContent -->
		</div>
		<!-- /content -->
		<!-- header -->
		<div id="mw-head" class="noprint">
			
<!-- 0 -->
<div id="p-personal" class="">
	<h5>Personal tools</h5>
	<ul>
		<li id="pt-login"><a href="/wiki/index.php?title=Special:UserLogin&amp;returnto=Utilities" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in / create account</a></li>
	</ul>
</div>

<!-- /0 -->
			<div id="left-navigation">
				
<!-- 0 -->
<div id="p-namespaces" class="vectorTabs">
	<h5>Namespaces</h5>
	<ul>
					<li  id="ca-nstab-main" class="selected"><span><a href="/wiki/index.php/Utilities"  title="View the content page [c]" accesskey="c">Page</a></span></li>
					<li  id="ca-talk" class="new"><span><a href="/wiki/index.php?title=Talk:Utilities&amp;action=edit&amp;redlink=1"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-variants" class="vectorMenu emptyPortlet">
	<h4>
		</h4>
	<h5><span>Variants</span><a href="#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->
			</div>
			<div id="right-navigation">
				
<!-- 0 -->
<div id="p-views" class="vectorTabs">
	<h5>Views</h5>
	<ul>
					<li id="ca-view" class="selected"><span><a href="/wiki/index.php/Utilities" >Read</a></span></li>
					<li id="ca-viewsource"><span><a href="/wiki/index.php?title=Utilities&amp;action=edit"  title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="/wiki/index.php?title=Utilities&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-cactions" class="vectorMenu emptyPortlet">
	<h5><span>Actions</span><a href="#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->

<!-- 2 -->
<div id="p-search">
	<h5><label for="searchInput">Search</label></h5>
	<form action="/wiki/index.php" id="searchform">
				<div>
			<input type="search" name="search" title="Search GridWiki [f]" accesskey="f" id="searchInput" />			<input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchGoButton" class="searchButton" />			<input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton" />					<input type='hidden' name="title" value="Special:Search"/>
		</div>
	</form>
</div>

<!-- /2 -->
			</div>
		</div>
		<!-- /header -->
		<!-- panel -->
			<div id="mw-panel" class="noprint">
				<!-- logo -->
					<div id="p-logo"><a style="background-image: url();" href="/wiki/index.php/Main_Page"  title="Visit the main page"></a></div>
				<!-- /logo -->
				
<!-- GridWiki Navigation -->
<div class="portal" id='p-GridWiki_Navigation'>
	<h5>GridWiki Navigation</h5>
	<div class="body">
		<ul>
			<li id="n-mainpage"><a href="/wiki/index.php/Main_Page" title="Visit the main page [z]" accesskey="z">Main Page</a></li>
			<li id="n-recentchanges"><a href="/wiki/index.php/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
			<li id="n-randompage"><a href="/wiki/index.php/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
			<li id="n-help"><a href="/wiki/index.php/Help:Contents" title="The place to find out">Help</a></li>
			<li id="n-sitesupport"><a href="/wiki/index.php/Sitesupport-url">sitesupport</a></li>
		</ul>
	</div>
</div>

<!-- /GridWiki Navigation -->

<!-- SEARCH -->

<!-- /SEARCH -->

<!-- TOOLBOX -->
<div class="portal" id='p-tb'>
	<h5>Toolbox</h5>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="/wiki/index.php/Special:WhatLinksHere/Utilities" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="/wiki/index.php/Special:RecentChangesLinked/Utilities" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
			<li id="t-specialpages"><a href="/wiki/index.php/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
			<li><a href="/wiki/index.php?title=Utilities&amp;printable=yes" rel="alternate">Printable version</a></li>
			<li id="t-permalink"><a href="/wiki/index.php?title=Utilities&amp;oldid=5193" title="Permanent link to this revision of the page">Permanent link</a></li>
		</ul>
	</div>
</div>

<!-- /TOOLBOX -->

<!-- LANGUAGES -->

<!-- /LANGUAGES -->
			</div>
		<!-- /panel -->
		<!-- footer -->
		<div id="footer">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 4 October 2012, at 23:46.</li>
											<li id="footer-info-viewcount">This page has been accessed 17,871 times.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="/wiki/index.php/GridWiki:Privacy_policy" title="GridWiki:Privacy policy">Privacy policy</a></li>
											<li id="footer-places-about"><a href="/wiki/index.php/GridWiki:About" title="GridWiki:About">About GridWiki</a></li>
											<li id="footer-places-disclaimer"><a href="/wiki/index.php/GridWiki:General_disclaimer" title="GridWiki:General disclaimer">Disclaimers</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-poweredbyico">
						<a href="//www.mediawiki.org/"><img src="/wiki/skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31" /></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<!-- /footer -->
		<script src="http://wiki.gridengine.info/wiki/load.php?debug=false&amp;lang=en&amp;modules=skins.vector&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.user","mediawiki.page.ready"], null, true);
}</script>
<!-- Served in 0.219 secs. -->
	</body>
</html>
